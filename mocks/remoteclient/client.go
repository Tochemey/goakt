// Code generated by mockery. DO NOT EDIT.

package remoteclient

import (
	context "context"

	extension "github.com/tochemey/goakt/v4/extension"
	address "github.com/tochemey/goakt/v4/internal/address"
	internalpb "github.com/tochemey/goakt/v4/internal/internalpb"

	tls "crypto/tls"
	time "time"

	mock "github.com/stretchr/testify/mock"
	net "github.com/tochemey/goakt/v4/internal/net"
	passivation "github.com/tochemey/goakt/v4/passivation"
	remote "github.com/tochemey/goakt/v4/remote"
)

// Client is an autogenerated mock type for the Client type
type Client struct {
	mock.Mock
}

type Client_Expecter struct {
	mock *mock.Mock
}

func (_m *Client) EXPECT() *Client_Expecter {
	return &Client_Expecter{mock: &_m.Mock}
}

// Close provides a mock function with no fields
func (_m *Client) Close() {
	_m.Called()
}

// Client_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type Client_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *Client_Expecter) Close() *Client_Close_Call {
	return &Client_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *Client_Close_Call) Run(run func()) *Client_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Client_Close_Call) Return() *Client_Close_Call {
	_c.Call.Return()
	return _c
}

func (_c *Client_Close_Call) RunAndReturn(run func()) *Client_Close_Call {
	_c.Run(run)
	return _c
}

// Compression provides a mock function with no fields
func (_m *Client) Compression() remote.Compression {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Compression")
	}

	var r0 remote.Compression
	if rf, ok := ret.Get(0).(func() remote.Compression); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(remote.Compression)
	}

	return r0
}

// Client_Compression_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Compression'
type Client_Compression_Call struct {
	*mock.Call
}

// Compression is a helper method to define mock.On call
func (_e *Client_Expecter) Compression() *Client_Compression_Call {
	return &Client_Compression_Call{Call: _e.mock.On("Compression")}
}

func (_c *Client_Compression_Call) Run(run func()) *Client_Compression_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Client_Compression_Call) Return(_a0 remote.Compression) *Client_Compression_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_Compression_Call) RunAndReturn(run func() remote.Compression) *Client_Compression_Call {
	_c.Call.Return(run)
	return _c
}

// NetClient provides a mock function with given fields: host, port
func (_m *Client) NetClient(host string, port int) *net.Client {
	ret := _m.Called(host, port)

	if len(ret) == 0 {
		panic("no return value specified for NetClient")
	}

	var r0 *net.Client
	if rf, ok := ret.Get(0).(func(string, int) *net.Client); ok {
		r0 = rf(host, port)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*net.Client)
		}
	}

	return r0
}

// Client_NetClient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetClient'
type Client_NetClient_Call struct {
	*mock.Call
}

// NetClient is a helper method to define mock.On call
//   - host string
//   - port int
func (_e *Client_Expecter) NetClient(host interface{}, port interface{}) *Client_NetClient_Call {
	return &Client_NetClient_Call{Call: _e.mock.On("NetClient", host, port)}
}

func (_c *Client_NetClient_Call) Run(run func(host string, port int)) *Client_NetClient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(int))
	})
	return _c
}

func (_c *Client_NetClient_Call) Return(_a0 *net.Client) *Client_NetClient_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_NetClient_Call) RunAndReturn(run func(string, int) *net.Client) *Client_NetClient_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteActivateGrain provides a mock function with given fields: ctx, host, port, grainRequest
func (_m *Client) RemoteActivateGrain(ctx context.Context, host string, port int, grainRequest *remote.GrainRequest) error {
	ret := _m.Called(ctx, host, port, grainRequest)

	if len(ret) == 0 {
		panic("no return value specified for RemoteActivateGrain")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *remote.GrainRequest) error); ok {
		r0 = rf(ctx, host, port, grainRequest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_RemoteActivateGrain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteActivateGrain'
type Client_RemoteActivateGrain_Call struct {
	*mock.Call
}

// RemoteActivateGrain is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - grainRequest *remote.GrainRequest
func (_e *Client_Expecter) RemoteActivateGrain(ctx interface{}, host interface{}, port interface{}, grainRequest interface{}) *Client_RemoteActivateGrain_Call {
	return &Client_RemoteActivateGrain_Call{Call: _e.mock.On("RemoteActivateGrain", ctx, host, port, grainRequest)}
}

func (_c *Client_RemoteActivateGrain_Call) Run(run func(ctx context.Context, host string, port int, grainRequest *remote.GrainRequest)) *Client_RemoteActivateGrain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(*remote.GrainRequest))
	})
	return _c
}

func (_c *Client_RemoteActivateGrain_Call) Return(_a0 error) *Client_RemoteActivateGrain_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_RemoteActivateGrain_Call) RunAndReturn(run func(context.Context, string, int, *remote.GrainRequest) error) *Client_RemoteActivateGrain_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteAsk provides a mock function with given fields: ctx, from, to, message, timeout
func (_m *Client) RemoteAsk(ctx context.Context, from *address.Address, to *address.Address, message interface{}, timeout time.Duration) (interface{}, error) {
	ret := _m.Called(ctx, from, to, message, timeout)

	if len(ret) == 0 {
		panic("no return value specified for RemoteAsk")
	}

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *address.Address, *address.Address, interface{}, time.Duration) (interface{}, error)); ok {
		return rf(ctx, from, to, message, timeout)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *address.Address, *address.Address, interface{}, time.Duration) interface{}); ok {
		r0 = rf(ctx, from, to, message, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *address.Address, *address.Address, interface{}, time.Duration) error); ok {
		r1 = rf(ctx, from, to, message, timeout)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_RemoteAsk_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteAsk'
type Client_RemoteAsk_Call struct {
	*mock.Call
}

// RemoteAsk is a helper method to define mock.On call
//   - ctx context.Context
//   - from *address.Address
//   - to *address.Address
//   - message interface{}
//   - timeout time.Duration
func (_e *Client_Expecter) RemoteAsk(ctx interface{}, from interface{}, to interface{}, message interface{}, timeout interface{}) *Client_RemoteAsk_Call {
	return &Client_RemoteAsk_Call{Call: _e.mock.On("RemoteAsk", ctx, from, to, message, timeout)}
}

func (_c *Client_RemoteAsk_Call) Run(run func(ctx context.Context, from *address.Address, to *address.Address, message interface{}, timeout time.Duration)) *Client_RemoteAsk_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*address.Address), args[2].(*address.Address), args[3].(interface{}), args[4].(time.Duration))
	})
	return _c
}

func (_c *Client_RemoteAsk_Call) Return(response interface{}, err error) *Client_RemoteAsk_Call {
	_c.Call.Return(response, err)
	return _c
}

func (_c *Client_RemoteAsk_Call) RunAndReturn(run func(context.Context, *address.Address, *address.Address, interface{}, time.Duration) (interface{}, error)) *Client_RemoteAsk_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteAskGrain provides a mock function with given fields: ctx, host, port, grainRequest, message, timeout
func (_m *Client) RemoteAskGrain(ctx context.Context, host string, port int, grainRequest *remote.GrainRequest, message interface{}, timeout time.Duration) (interface{}, error) {
	ret := _m.Called(ctx, host, port, grainRequest, message, timeout)

	if len(ret) == 0 {
		panic("no return value specified for RemoteAskGrain")
	}

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *remote.GrainRequest, interface{}, time.Duration) (interface{}, error)); ok {
		return rf(ctx, host, port, grainRequest, message, timeout)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *remote.GrainRequest, interface{}, time.Duration) interface{}); ok {
		r0 = rf(ctx, host, port, grainRequest, message, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, *remote.GrainRequest, interface{}, time.Duration) error); ok {
		r1 = rf(ctx, host, port, grainRequest, message, timeout)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_RemoteAskGrain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteAskGrain'
type Client_RemoteAskGrain_Call struct {
	*mock.Call
}

// RemoteAskGrain is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - grainRequest *remote.GrainRequest
//   - message interface{}
//   - timeout time.Duration
func (_e *Client_Expecter) RemoteAskGrain(ctx interface{}, host interface{}, port interface{}, grainRequest interface{}, message interface{}, timeout interface{}) *Client_RemoteAskGrain_Call {
	return &Client_RemoteAskGrain_Call{Call: _e.mock.On("RemoteAskGrain", ctx, host, port, grainRequest, message, timeout)}
}

func (_c *Client_RemoteAskGrain_Call) Run(run func(ctx context.Context, host string, port int, grainRequest *remote.GrainRequest, message interface{}, timeout time.Duration)) *Client_RemoteAskGrain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(*remote.GrainRequest), args[4].(interface{}), args[5].(time.Duration))
	})
	return _c
}

func (_c *Client_RemoteAskGrain_Call) Return(response interface{}, err error) *Client_RemoteAskGrain_Call {
	_c.Call.Return(response, err)
	return _c
}

func (_c *Client_RemoteAskGrain_Call) RunAndReturn(run func(context.Context, string, int, *remote.GrainRequest, interface{}, time.Duration) (interface{}, error)) *Client_RemoteAskGrain_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteBatchAsk provides a mock function with given fields: ctx, from, to, messages, timeout
func (_m *Client) RemoteBatchAsk(ctx context.Context, from *address.Address, to *address.Address, messages []interface{}, timeout time.Duration) ([]interface{}, error) {
	ret := _m.Called(ctx, from, to, messages, timeout)

	if len(ret) == 0 {
		panic("no return value specified for RemoteBatchAsk")
	}

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *address.Address, *address.Address, []interface{}, time.Duration) ([]interface{}, error)); ok {
		return rf(ctx, from, to, messages, timeout)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *address.Address, *address.Address, []interface{}, time.Duration) []interface{}); ok {
		r0 = rf(ctx, from, to, messages, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *address.Address, *address.Address, []interface{}, time.Duration) error); ok {
		r1 = rf(ctx, from, to, messages, timeout)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_RemoteBatchAsk_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteBatchAsk'
type Client_RemoteBatchAsk_Call struct {
	*mock.Call
}

// RemoteBatchAsk is a helper method to define mock.On call
//   - ctx context.Context
//   - from *address.Address
//   - to *address.Address
//   - messages []interface{}
//   - timeout time.Duration
func (_e *Client_Expecter) RemoteBatchAsk(ctx interface{}, from interface{}, to interface{}, messages interface{}, timeout interface{}) *Client_RemoteBatchAsk_Call {
	return &Client_RemoteBatchAsk_Call{Call: _e.mock.On("RemoteBatchAsk", ctx, from, to, messages, timeout)}
}

func (_c *Client_RemoteBatchAsk_Call) Run(run func(ctx context.Context, from *address.Address, to *address.Address, messages []interface{}, timeout time.Duration)) *Client_RemoteBatchAsk_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*address.Address), args[2].(*address.Address), args[3].([]interface{}), args[4].(time.Duration))
	})
	return _c
}

func (_c *Client_RemoteBatchAsk_Call) Return(responses []interface{}, err error) *Client_RemoteBatchAsk_Call {
	_c.Call.Return(responses, err)
	return _c
}

func (_c *Client_RemoteBatchAsk_Call) RunAndReturn(run func(context.Context, *address.Address, *address.Address, []interface{}, time.Duration) ([]interface{}, error)) *Client_RemoteBatchAsk_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteBatchTell provides a mock function with given fields: ctx, from, to, messages
func (_m *Client) RemoteBatchTell(ctx context.Context, from *address.Address, to *address.Address, messages []interface{}) error {
	ret := _m.Called(ctx, from, to, messages)

	if len(ret) == 0 {
		panic("no return value specified for RemoteBatchTell")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *address.Address, *address.Address, []interface{}) error); ok {
		r0 = rf(ctx, from, to, messages)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_RemoteBatchTell_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteBatchTell'
type Client_RemoteBatchTell_Call struct {
	*mock.Call
}

// RemoteBatchTell is a helper method to define mock.On call
//   - ctx context.Context
//   - from *address.Address
//   - to *address.Address
//   - messages []interface{}
func (_e *Client_Expecter) RemoteBatchTell(ctx interface{}, from interface{}, to interface{}, messages interface{}) *Client_RemoteBatchTell_Call {
	return &Client_RemoteBatchTell_Call{Call: _e.mock.On("RemoteBatchTell", ctx, from, to, messages)}
}

func (_c *Client_RemoteBatchTell_Call) Run(run func(ctx context.Context, from *address.Address, to *address.Address, messages []interface{})) *Client_RemoteBatchTell_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*address.Address), args[2].(*address.Address), args[3].([]interface{}))
	})
	return _c
}

func (_c *Client_RemoteBatchTell_Call) Return(_a0 error) *Client_RemoteBatchTell_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_RemoteBatchTell_Call) RunAndReturn(run func(context.Context, *address.Address, *address.Address, []interface{}) error) *Client_RemoteBatchTell_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteChildren provides a mock function with given fields: ctx, host, port, name
func (_m *Client) RemoteChildren(ctx context.Context, host string, port int, name string) ([]*address.Address, error) {
	ret := _m.Called(ctx, host, port, name)

	if len(ret) == 0 {
		panic("no return value specified for RemoteChildren")
	}

	var r0 []*address.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) ([]*address.Address, error)); ok {
		return rf(ctx, host, port, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) []*address.Address); ok {
		r0 = rf(ctx, host, port, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*address.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, string) error); ok {
		r1 = rf(ctx, host, port, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_RemoteChildren_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteChildren'
type Client_RemoteChildren_Call struct {
	*mock.Call
}

// RemoteChildren is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - name string
func (_e *Client_Expecter) RemoteChildren(ctx interface{}, host interface{}, port interface{}, name interface{}) *Client_RemoteChildren_Call {
	return &Client_RemoteChildren_Call{Call: _e.mock.On("RemoteChildren", ctx, host, port, name)}
}

func (_c *Client_RemoteChildren_Call) Run(run func(ctx context.Context, host string, port int, name string)) *Client_RemoteChildren_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *Client_RemoteChildren_Call) Return(addresses []*address.Address, err error) *Client_RemoteChildren_Call {
	_c.Call.Return(addresses, err)
	return _c
}

func (_c *Client_RemoteChildren_Call) RunAndReturn(run func(context.Context, string, int, string) ([]*address.Address, error)) *Client_RemoteChildren_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteDependencies provides a mock function with given fields: ctx, host, port, name
func (_m *Client) RemoteDependencies(ctx context.Context, host string, port int, name string) ([]extension.Dependency, error) {
	ret := _m.Called(ctx, host, port, name)

	if len(ret) == 0 {
		panic("no return value specified for RemoteDependencies")
	}

	var r0 []extension.Dependency
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) ([]extension.Dependency, error)); ok {
		return rf(ctx, host, port, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) []extension.Dependency); ok {
		r0 = rf(ctx, host, port, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]extension.Dependency)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, string) error); ok {
		r1 = rf(ctx, host, port, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_RemoteDependencies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteDependencies'
type Client_RemoteDependencies_Call struct {
	*mock.Call
}

// RemoteDependencies is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - name string
func (_e *Client_Expecter) RemoteDependencies(ctx interface{}, host interface{}, port interface{}, name interface{}) *Client_RemoteDependencies_Call {
	return &Client_RemoteDependencies_Call{Call: _e.mock.On("RemoteDependencies", ctx, host, port, name)}
}

func (_c *Client_RemoteDependencies_Call) Run(run func(ctx context.Context, host string, port int, name string)) *Client_RemoteDependencies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *Client_RemoteDependencies_Call) Return(dependencies []extension.Dependency, err error) *Client_RemoteDependencies_Call {
	_c.Call.Return(dependencies, err)
	return _c
}

func (_c *Client_RemoteDependencies_Call) RunAndReturn(run func(context.Context, string, int, string) ([]extension.Dependency, error)) *Client_RemoteDependencies_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteKind provides a mock function with given fields: ctx, host, port, name
func (_m *Client) RemoteKind(ctx context.Context, host string, port int, name string) (string, error) {
	ret := _m.Called(ctx, host, port, name)

	if len(ret) == 0 {
		panic("no return value specified for RemoteKind")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) (string, error)); ok {
		return rf(ctx, host, port, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) string); ok {
		r0 = rf(ctx, host, port, name)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, string) error); ok {
		r1 = rf(ctx, host, port, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_RemoteKind_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteKind'
type Client_RemoteKind_Call struct {
	*mock.Call
}

// RemoteKind is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - name string
func (_e *Client_Expecter) RemoteKind(ctx interface{}, host interface{}, port interface{}, name interface{}) *Client_RemoteKind_Call {
	return &Client_RemoteKind_Call{Call: _e.mock.On("RemoteKind", ctx, host, port, name)}
}

func (_c *Client_RemoteKind_Call) Run(run func(ctx context.Context, host string, port int, name string)) *Client_RemoteKind_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *Client_RemoteKind_Call) Return(kind string, err error) *Client_RemoteKind_Call {
	_c.Call.Return(kind, err)
	return _c
}

func (_c *Client_RemoteKind_Call) RunAndReturn(run func(context.Context, string, int, string) (string, error)) *Client_RemoteKind_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteLookup provides a mock function with given fields: ctx, host, port, name
func (_m *Client) RemoteLookup(ctx context.Context, host string, port int, name string) (*address.Address, error) {
	ret := _m.Called(ctx, host, port, name)

	if len(ret) == 0 {
		panic("no return value specified for RemoteLookup")
	}

	var r0 *address.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) (*address.Address, error)); ok {
		return rf(ctx, host, port, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) *address.Address); ok {
		r0 = rf(ctx, host, port, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*address.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, string) error); ok {
		r1 = rf(ctx, host, port, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_RemoteLookup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteLookup'
type Client_RemoteLookup_Call struct {
	*mock.Call
}

// RemoteLookup is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - name string
func (_e *Client_Expecter) RemoteLookup(ctx interface{}, host interface{}, port interface{}, name interface{}) *Client_RemoteLookup_Call {
	return &Client_RemoteLookup_Call{Call: _e.mock.On("RemoteLookup", ctx, host, port, name)}
}

func (_c *Client_RemoteLookup_Call) Run(run func(ctx context.Context, host string, port int, name string)) *Client_RemoteLookup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *Client_RemoteLookup_Call) Return(addr *address.Address, err error) *Client_RemoteLookup_Call {
	_c.Call.Return(addr, err)
	return _c
}

func (_c *Client_RemoteLookup_Call) RunAndReturn(run func(context.Context, string, int, string) (*address.Address, error)) *Client_RemoteLookup_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteMetric provides a mock function with given fields: ctx, host, port, name
func (_m *Client) RemoteMetric(ctx context.Context, host string, port int, name string) (*internalpb.Metric, error) {
	ret := _m.Called(ctx, host, port, name)

	if len(ret) == 0 {
		panic("no return value specified for RemoteMetric")
	}

	var r0 *internalpb.Metric
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) (*internalpb.Metric, error)); ok {
		return rf(ctx, host, port, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) *internalpb.Metric); ok {
		r0 = rf(ctx, host, port, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*internalpb.Metric)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, string) error); ok {
		r1 = rf(ctx, host, port, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_RemoteMetric_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteMetric'
type Client_RemoteMetric_Call struct {
	*mock.Call
}

// RemoteMetric is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - name string
func (_e *Client_Expecter) RemoteMetric(ctx interface{}, host interface{}, port interface{}, name interface{}) *Client_RemoteMetric_Call {
	return &Client_RemoteMetric_Call{Call: _e.mock.On("RemoteMetric", ctx, host, port, name)}
}

func (_c *Client_RemoteMetric_Call) Run(run func(ctx context.Context, host string, port int, name string)) *Client_RemoteMetric_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *Client_RemoteMetric_Call) Return(metric *internalpb.Metric, err error) *Client_RemoteMetric_Call {
	_c.Call.Return(metric, err)
	return _c
}

func (_c *Client_RemoteMetric_Call) RunAndReturn(run func(context.Context, string, int, string) (*internalpb.Metric, error)) *Client_RemoteMetric_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteParent provides a mock function with given fields: ctx, host, port, name
func (_m *Client) RemoteParent(ctx context.Context, host string, port int, name string) (*address.Address, error) {
	ret := _m.Called(ctx, host, port, name)

	if len(ret) == 0 {
		panic("no return value specified for RemoteParent")
	}

	var r0 *address.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) (*address.Address, error)); ok {
		return rf(ctx, host, port, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) *address.Address); ok {
		r0 = rf(ctx, host, port, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*address.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, string) error); ok {
		r1 = rf(ctx, host, port, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_RemoteParent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteParent'
type Client_RemoteParent_Call struct {
	*mock.Call
}

// RemoteParent is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - name string
func (_e *Client_Expecter) RemoteParent(ctx interface{}, host interface{}, port interface{}, name interface{}) *Client_RemoteParent_Call {
	return &Client_RemoteParent_Call{Call: _e.mock.On("RemoteParent", ctx, host, port, name)}
}

func (_c *Client_RemoteParent_Call) Run(run func(ctx context.Context, host string, port int, name string)) *Client_RemoteParent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *Client_RemoteParent_Call) Return(parent *address.Address, err error) *Client_RemoteParent_Call {
	_c.Call.Return(parent, err)
	return _c
}

func (_c *Client_RemoteParent_Call) RunAndReturn(run func(context.Context, string, int, string) (*address.Address, error)) *Client_RemoteParent_Call {
	_c.Call.Return(run)
	return _c
}

// RemotePassivationStrategy provides a mock function with given fields: ctx, host, port, name
func (_m *Client) RemotePassivationStrategy(ctx context.Context, host string, port int, name string) (passivation.Strategy, error) {
	ret := _m.Called(ctx, host, port, name)

	if len(ret) == 0 {
		panic("no return value specified for RemotePassivationStrategy")
	}

	var r0 passivation.Strategy
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) (passivation.Strategy, error)); ok {
		return rf(ctx, host, port, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) passivation.Strategy); ok {
		r0 = rf(ctx, host, port, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(passivation.Strategy)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, string) error); ok {
		r1 = rf(ctx, host, port, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_RemotePassivationStrategy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemotePassivationStrategy'
type Client_RemotePassivationStrategy_Call struct {
	*mock.Call
}

// RemotePassivationStrategy is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - name string
func (_e *Client_Expecter) RemotePassivationStrategy(ctx interface{}, host interface{}, port interface{}, name interface{}) *Client_RemotePassivationStrategy_Call {
	return &Client_RemotePassivationStrategy_Call{Call: _e.mock.On("RemotePassivationStrategy", ctx, host, port, name)}
}

func (_c *Client_RemotePassivationStrategy_Call) Run(run func(ctx context.Context, host string, port int, name string)) *Client_RemotePassivationStrategy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *Client_RemotePassivationStrategy_Call) Return(strategy passivation.Strategy, err error) *Client_RemotePassivationStrategy_Call {
	_c.Call.Return(strategy, err)
	return _c
}

func (_c *Client_RemotePassivationStrategy_Call) RunAndReturn(run func(context.Context, string, int, string) (passivation.Strategy, error)) *Client_RemotePassivationStrategy_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteReSpawn provides a mock function with given fields: ctx, host, port, name
func (_m *Client) RemoteReSpawn(ctx context.Context, host string, port int, name string) (*string, error) {
	ret := _m.Called(ctx, host, port, name)

	if len(ret) == 0 {
		panic("no return value specified for RemoteReSpawn")
	}

	var r0 *string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) (*string, error)); ok {
		return rf(ctx, host, port, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) *string); ok {
		r0 = rf(ctx, host, port, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, string) error); ok {
		r1 = rf(ctx, host, port, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_RemoteReSpawn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteReSpawn'
type Client_RemoteReSpawn_Call struct {
	*mock.Call
}

// RemoteReSpawn is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - name string
func (_e *Client_Expecter) RemoteReSpawn(ctx interface{}, host interface{}, port interface{}, name interface{}) *Client_RemoteReSpawn_Call {
	return &Client_RemoteReSpawn_Call{Call: _e.mock.On("RemoteReSpawn", ctx, host, port, name)}
}

func (_c *Client_RemoteReSpawn_Call) Run(run func(ctx context.Context, host string, port int, name string)) *Client_RemoteReSpawn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *Client_RemoteReSpawn_Call) Return(_a0 *string, _a1 error) *Client_RemoteReSpawn_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_RemoteReSpawn_Call) RunAndReturn(run func(context.Context, string, int, string) (*string, error)) *Client_RemoteReSpawn_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteReinstate provides a mock function with given fields: ctx, host, port, name
func (_m *Client) RemoteReinstate(ctx context.Context, host string, port int, name string) error {
	ret := _m.Called(ctx, host, port, name)

	if len(ret) == 0 {
		panic("no return value specified for RemoteReinstate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) error); ok {
		r0 = rf(ctx, host, port, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_RemoteReinstate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteReinstate'
type Client_RemoteReinstate_Call struct {
	*mock.Call
}

// RemoteReinstate is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - name string
func (_e *Client_Expecter) RemoteReinstate(ctx interface{}, host interface{}, port interface{}, name interface{}) *Client_RemoteReinstate_Call {
	return &Client_RemoteReinstate_Call{Call: _e.mock.On("RemoteReinstate", ctx, host, port, name)}
}

func (_c *Client_RemoteReinstate_Call) Run(run func(ctx context.Context, host string, port int, name string)) *Client_RemoteReinstate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *Client_RemoteReinstate_Call) Return(_a0 error) *Client_RemoteReinstate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_RemoteReinstate_Call) RunAndReturn(run func(context.Context, string, int, string) error) *Client_RemoteReinstate_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteRole provides a mock function with given fields: ctx, host, port, name
func (_m *Client) RemoteRole(ctx context.Context, host string, port int, name string) (string, error) {
	ret := _m.Called(ctx, host, port, name)

	if len(ret) == 0 {
		panic("no return value specified for RemoteRole")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) (string, error)); ok {
		return rf(ctx, host, port, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) string); ok {
		r0 = rf(ctx, host, port, name)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, string) error); ok {
		r1 = rf(ctx, host, port, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_RemoteRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteRole'
type Client_RemoteRole_Call struct {
	*mock.Call
}

// RemoteRole is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - name string
func (_e *Client_Expecter) RemoteRole(ctx interface{}, host interface{}, port interface{}, name interface{}) *Client_RemoteRole_Call {
	return &Client_RemoteRole_Call{Call: _e.mock.On("RemoteRole", ctx, host, port, name)}
}

func (_c *Client_RemoteRole_Call) Run(run func(ctx context.Context, host string, port int, name string)) *Client_RemoteRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *Client_RemoteRole_Call) Return(role string, err error) *Client_RemoteRole_Call {
	_c.Call.Return(role, err)
	return _c
}

func (_c *Client_RemoteRole_Call) RunAndReturn(run func(context.Context, string, int, string) (string, error)) *Client_RemoteRole_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteSpawn provides a mock function with given fields: ctx, host, port, spawnRequest
func (_m *Client) RemoteSpawn(ctx context.Context, host string, port int, spawnRequest *remote.SpawnRequest) (*string, error) {
	ret := _m.Called(ctx, host, port, spawnRequest)

	if len(ret) == 0 {
		panic("no return value specified for RemoteSpawn")
	}

	var r0 *string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *remote.SpawnRequest) (*string, error)); ok {
		return rf(ctx, host, port, spawnRequest)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *remote.SpawnRequest) *string); ok {
		r0 = rf(ctx, host, port, spawnRequest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, *remote.SpawnRequest) error); ok {
		r1 = rf(ctx, host, port, spawnRequest)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_RemoteSpawn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteSpawn'
type Client_RemoteSpawn_Call struct {
	*mock.Call
}

// RemoteSpawn is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - spawnRequest *remote.SpawnRequest
func (_e *Client_Expecter) RemoteSpawn(ctx interface{}, host interface{}, port interface{}, spawnRequest interface{}) *Client_RemoteSpawn_Call {
	return &Client_RemoteSpawn_Call{Call: _e.mock.On("RemoteSpawn", ctx, host, port, spawnRequest)}
}

func (_c *Client_RemoteSpawn_Call) Run(run func(ctx context.Context, host string, port int, spawnRequest *remote.SpawnRequest)) *Client_RemoteSpawn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(*remote.SpawnRequest))
	})
	return _c
}

func (_c *Client_RemoteSpawn_Call) Return(_a0 *string, _a1 error) *Client_RemoteSpawn_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_RemoteSpawn_Call) RunAndReturn(run func(context.Context, string, int, *remote.SpawnRequest) (*string, error)) *Client_RemoteSpawn_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteSpawnChild provides a mock function with given fields: ctx, host, port, childRequest
func (_m *Client) RemoteSpawnChild(ctx context.Context, host string, port int, childRequest *remote.SpawnChildRequest) (*address.Address, error) {
	ret := _m.Called(ctx, host, port, childRequest)

	if len(ret) == 0 {
		panic("no return value specified for RemoteSpawnChild")
	}

	var r0 *address.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *remote.SpawnChildRequest) (*address.Address, error)); ok {
		return rf(ctx, host, port, childRequest)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *remote.SpawnChildRequest) *address.Address); ok {
		r0 = rf(ctx, host, port, childRequest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*address.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, *remote.SpawnChildRequest) error); ok {
		r1 = rf(ctx, host, port, childRequest)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_RemoteSpawnChild_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteSpawnChild'
type Client_RemoteSpawnChild_Call struct {
	*mock.Call
}

// RemoteSpawnChild is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - childRequest *remote.SpawnChildRequest
func (_e *Client_Expecter) RemoteSpawnChild(ctx interface{}, host interface{}, port interface{}, childRequest interface{}) *Client_RemoteSpawnChild_Call {
	return &Client_RemoteSpawnChild_Call{Call: _e.mock.On("RemoteSpawnChild", ctx, host, port, childRequest)}
}

func (_c *Client_RemoteSpawnChild_Call) Run(run func(ctx context.Context, host string, port int, childRequest *remote.SpawnChildRequest)) *Client_RemoteSpawnChild_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(*remote.SpawnChildRequest))
	})
	return _c
}

func (_c *Client_RemoteSpawnChild_Call) Return(_a0 *address.Address, _a1 error) *Client_RemoteSpawnChild_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_RemoteSpawnChild_Call) RunAndReturn(run func(context.Context, string, int, *remote.SpawnChildRequest) (*address.Address, error)) *Client_RemoteSpawnChild_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteStashSize provides a mock function with given fields: ctx, host, port, name
func (_m *Client) RemoteStashSize(ctx context.Context, host string, port int, name string) (uint64, error) {
	ret := _m.Called(ctx, host, port, name)

	if len(ret) == 0 {
		panic("no return value specified for RemoteStashSize")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) (uint64, error)); ok {
		return rf(ctx, host, port, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) uint64); ok {
		r0 = rf(ctx, host, port, name)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, string) error); ok {
		r1 = rf(ctx, host, port, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_RemoteStashSize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteStashSize'
type Client_RemoteStashSize_Call struct {
	*mock.Call
}

// RemoteStashSize is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - name string
func (_e *Client_Expecter) RemoteStashSize(ctx interface{}, host interface{}, port interface{}, name interface{}) *Client_RemoteStashSize_Call {
	return &Client_RemoteStashSize_Call{Call: _e.mock.On("RemoteStashSize", ctx, host, port, name)}
}

func (_c *Client_RemoteStashSize_Call) Run(run func(ctx context.Context, host string, port int, name string)) *Client_RemoteStashSize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *Client_RemoteStashSize_Call) Return(size uint64, err error) *Client_RemoteStashSize_Call {
	_c.Call.Return(size, err)
	return _c
}

func (_c *Client_RemoteStashSize_Call) RunAndReturn(run func(context.Context, string, int, string) (uint64, error)) *Client_RemoteStashSize_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteState provides a mock function with given fields: ctx, host, port, name, state
func (_m *Client) RemoteState(ctx context.Context, host string, port int, name string, state remote.ActorState) (bool, error) {
	ret := _m.Called(ctx, host, port, name, state)

	if len(ret) == 0 {
		panic("no return value specified for RemoteState")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string, remote.ActorState) (bool, error)); ok {
		return rf(ctx, host, port, name, state)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string, remote.ActorState) bool); ok {
		r0 = rf(ctx, host, port, name, state)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, string, remote.ActorState) error); ok {
		r1 = rf(ctx, host, port, name, state)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_RemoteState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteState'
type Client_RemoteState_Call struct {
	*mock.Call
}

// RemoteState is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - name string
//   - state remote.ActorState
func (_e *Client_Expecter) RemoteState(ctx interface{}, host interface{}, port interface{}, name interface{}, state interface{}) *Client_RemoteState_Call {
	return &Client_RemoteState_Call{Call: _e.mock.On("RemoteState", ctx, host, port, name, state)}
}

func (_c *Client_RemoteState_Call) Run(run func(ctx context.Context, host string, port int, name string, state remote.ActorState)) *Client_RemoteState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string), args[4].(remote.ActorState))
	})
	return _c
}

func (_c *Client_RemoteState_Call) Return(ok bool, err error) *Client_RemoteState_Call {
	_c.Call.Return(ok, err)
	return _c
}

func (_c *Client_RemoteState_Call) RunAndReturn(run func(context.Context, string, int, string, remote.ActorState) (bool, error)) *Client_RemoteState_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteStop provides a mock function with given fields: ctx, host, port, name
func (_m *Client) RemoteStop(ctx context.Context, host string, port int, name string) error {
	ret := _m.Called(ctx, host, port, name)

	if len(ret) == 0 {
		panic("no return value specified for RemoteStop")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) error); ok {
		r0 = rf(ctx, host, port, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_RemoteStop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteStop'
type Client_RemoteStop_Call struct {
	*mock.Call
}

// RemoteStop is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - name string
func (_e *Client_Expecter) RemoteStop(ctx interface{}, host interface{}, port interface{}, name interface{}) *Client_RemoteStop_Call {
	return &Client_RemoteStop_Call{Call: _e.mock.On("RemoteStop", ctx, host, port, name)}
}

func (_c *Client_RemoteStop_Call) Run(run func(ctx context.Context, host string, port int, name string)) *Client_RemoteStop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *Client_RemoteStop_Call) Return(_a0 error) *Client_RemoteStop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_RemoteStop_Call) RunAndReturn(run func(context.Context, string, int, string) error) *Client_RemoteStop_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteTell provides a mock function with given fields: ctx, from, to, message
func (_m *Client) RemoteTell(ctx context.Context, from *address.Address, to *address.Address, message interface{}) error {
	ret := _m.Called(ctx, from, to, message)

	if len(ret) == 0 {
		panic("no return value specified for RemoteTell")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *address.Address, *address.Address, interface{}) error); ok {
		r0 = rf(ctx, from, to, message)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_RemoteTell_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteTell'
type Client_RemoteTell_Call struct {
	*mock.Call
}

// RemoteTell is a helper method to define mock.On call
//   - ctx context.Context
//   - from *address.Address
//   - to *address.Address
//   - message interface{}
func (_e *Client_Expecter) RemoteTell(ctx interface{}, from interface{}, to interface{}, message interface{}) *Client_RemoteTell_Call {
	return &Client_RemoteTell_Call{Call: _e.mock.On("RemoteTell", ctx, from, to, message)}
}

func (_c *Client_RemoteTell_Call) Run(run func(ctx context.Context, from *address.Address, to *address.Address, message interface{})) *Client_RemoteTell_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*address.Address), args[2].(*address.Address), args[3].(interface{}))
	})
	return _c
}

func (_c *Client_RemoteTell_Call) Return(_a0 error) *Client_RemoteTell_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_RemoteTell_Call) RunAndReturn(run func(context.Context, *address.Address, *address.Address, interface{}) error) *Client_RemoteTell_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteTellGrain provides a mock function with given fields: ctx, host, port, grainRequest, message
func (_m *Client) RemoteTellGrain(ctx context.Context, host string, port int, grainRequest *remote.GrainRequest, message interface{}) error {
	ret := _m.Called(ctx, host, port, grainRequest, message)

	if len(ret) == 0 {
		panic("no return value specified for RemoteTellGrain")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *remote.GrainRequest, interface{}) error); ok {
		r0 = rf(ctx, host, port, grainRequest, message)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_RemoteTellGrain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteTellGrain'
type Client_RemoteTellGrain_Call struct {
	*mock.Call
}

// RemoteTellGrain is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - grainRequest *remote.GrainRequest
//   - message interface{}
func (_e *Client_Expecter) RemoteTellGrain(ctx interface{}, host interface{}, port interface{}, grainRequest interface{}, message interface{}) *Client_RemoteTellGrain_Call {
	return &Client_RemoteTellGrain_Call{Call: _e.mock.On("RemoteTellGrain", ctx, host, port, grainRequest, message)}
}

func (_c *Client_RemoteTellGrain_Call) Run(run func(ctx context.Context, host string, port int, grainRequest *remote.GrainRequest, message interface{})) *Client_RemoteTellGrain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(*remote.GrainRequest), args[4].(interface{}))
	})
	return _c
}

func (_c *Client_RemoteTellGrain_Call) Return(_a0 error) *Client_RemoteTellGrain_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_RemoteTellGrain_Call) RunAndReturn(run func(context.Context, string, int, *remote.GrainRequest, interface{}) error) *Client_RemoteTellGrain_Call {
	_c.Call.Return(run)
	return _c
}

// Serializer provides a mock function with given fields: msg
func (_m *Client) Serializer(msg interface{}) remote.Serializer {
	ret := _m.Called(msg)

	if len(ret) == 0 {
		panic("no return value specified for Serializer")
	}

	var r0 remote.Serializer
	if rf, ok := ret.Get(0).(func(interface{}) remote.Serializer); ok {
		r0 = rf(msg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(remote.Serializer)
		}
	}

	return r0
}

// Client_Serializer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Serializer'
type Client_Serializer_Call struct {
	*mock.Call
}

// Serializer is a helper method to define mock.On call
//   - msg interface{}
func (_e *Client_Expecter) Serializer(msg interface{}) *Client_Serializer_Call {
	return &Client_Serializer_Call{Call: _e.mock.On("Serializer", msg)}
}

func (_c *Client_Serializer_Call) Run(run func(msg interface{})) *Client_Serializer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *Client_Serializer_Call) Return(_a0 remote.Serializer) *Client_Serializer_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_Serializer_Call) RunAndReturn(run func(interface{}) remote.Serializer) *Client_Serializer_Call {
	_c.Call.Return(run)
	return _c
}

// TLSConfig provides a mock function with no fields
func (_m *Client) TLSConfig() *tls.Config {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for TLSConfig")
	}

	var r0 *tls.Config
	if rf, ok := ret.Get(0).(func() *tls.Config); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tls.Config)
		}
	}

	return r0
}

// Client_TLSConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TLSConfig'
type Client_TLSConfig_Call struct {
	*mock.Call
}

// TLSConfig is a helper method to define mock.On call
func (_e *Client_Expecter) TLSConfig() *Client_TLSConfig_Call {
	return &Client_TLSConfig_Call{Call: _e.mock.On("TLSConfig")}
}

func (_c *Client_TLSConfig_Call) Run(run func()) *Client_TLSConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Client_TLSConfig_Call) Return(_a0 *tls.Config) *Client_TLSConfig_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_TLSConfig_Call) RunAndReturn(run func() *tls.Config) *Client_TLSConfig_Call {
	_c.Call.Return(run)
	return _c
}

// NewClient creates a new instance of Client. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *Client {
	mock := &Client{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
