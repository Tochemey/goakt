// Code generated by mockery. DO NOT EDIT.

package remote

import (
	address "github.com/tochemey/goakt/v3/address"
	anypb "google.golang.org/protobuf/types/known/anypb"

	context "context"

	http "net/http"

	internalpbconnect "github.com/tochemey/goakt/v3/internal/internalpb/internalpbconnect"

	mock "github.com/stretchr/testify/mock"

	protoreflect "google.golang.org/protobuf/reflect/protoreflect"

	time "time"

	v3remote "github.com/tochemey/goakt/v3/remote"
)

// Remoting is an autogenerated mock type for the Remoting type
type Remoting struct {
	mock.Mock
}

type Remoting_Expecter struct {
	mock *mock.Mock
}

func (_m *Remoting) EXPECT() *Remoting_Expecter {
	return &Remoting_Expecter{mock: &_m.Mock}
}

// Close provides a mock function with no fields
func (_m *Remoting) Close() {
	_m.Called()
}

// Remoting_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type Remoting_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *Remoting_Expecter) Close() *Remoting_Close_Call {
	return &Remoting_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *Remoting_Close_Call) Run(run func()) *Remoting_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Remoting_Close_Call) Return() *Remoting_Close_Call {
	_c.Call.Return()
	return _c
}

func (_c *Remoting_Close_Call) RunAndReturn(run func()) *Remoting_Close_Call {
	_c.Run(run)
	return _c
}

// Compression provides a mock function with no fields
func (_m *Remoting) Compression() v3remote.Compression {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Compression")
	}

	var r0 v3remote.Compression
	if rf, ok := ret.Get(0).(func() v3remote.Compression); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(v3remote.Compression)
	}

	return r0
}

// Remoting_Compression_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Compression'
type Remoting_Compression_Call struct {
	*mock.Call
}

// Compression is a helper method to define mock.On call
func (_e *Remoting_Expecter) Compression() *Remoting_Compression_Call {
	return &Remoting_Compression_Call{Call: _e.mock.On("Compression")}
}

func (_c *Remoting_Compression_Call) Run(run func()) *Remoting_Compression_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Remoting_Compression_Call) Return(_a0 v3remote.Compression) *Remoting_Compression_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Remoting_Compression_Call) RunAndReturn(run func() v3remote.Compression) *Remoting_Compression_Call {
	_c.Call.Return(run)
	return _c
}

// HTTPClient provides a mock function with no fields
func (_m *Remoting) HTTPClient() *http.Client {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for HTTPClient")
	}

	var r0 *http.Client
	if rf, ok := ret.Get(0).(func() *http.Client); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Client)
		}
	}

	return r0
}

// Remoting_HTTPClient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HTTPClient'
type Remoting_HTTPClient_Call struct {
	*mock.Call
}

// HTTPClient is a helper method to define mock.On call
func (_e *Remoting_Expecter) HTTPClient() *Remoting_HTTPClient_Call {
	return &Remoting_HTTPClient_Call{Call: _e.mock.On("HTTPClient")}
}

func (_c *Remoting_HTTPClient_Call) Run(run func()) *Remoting_HTTPClient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Remoting_HTTPClient_Call) Return(_a0 *http.Client) *Remoting_HTTPClient_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Remoting_HTTPClient_Call) RunAndReturn(run func() *http.Client) *Remoting_HTTPClient_Call {
	_c.Call.Return(run)
	return _c
}

// MaxReadFrameSize provides a mock function with no fields
func (_m *Remoting) MaxReadFrameSize() int {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for MaxReadFrameSize")
	}

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// Remoting_MaxReadFrameSize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MaxReadFrameSize'
type Remoting_MaxReadFrameSize_Call struct {
	*mock.Call
}

// MaxReadFrameSize is a helper method to define mock.On call
func (_e *Remoting_Expecter) MaxReadFrameSize() *Remoting_MaxReadFrameSize_Call {
	return &Remoting_MaxReadFrameSize_Call{Call: _e.mock.On("MaxReadFrameSize")}
}

func (_c *Remoting_MaxReadFrameSize_Call) Run(run func()) *Remoting_MaxReadFrameSize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Remoting_MaxReadFrameSize_Call) Return(_a0 int) *Remoting_MaxReadFrameSize_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Remoting_MaxReadFrameSize_Call) RunAndReturn(run func() int) *Remoting_MaxReadFrameSize_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteAsk provides a mock function with given fields: ctx, from, to, message, timeout
func (_m *Remoting) RemoteAsk(ctx context.Context, from *address.Address, to *address.Address, message protoreflect.ProtoMessage, timeout time.Duration) (*anypb.Any, error) {
	ret := _m.Called(ctx, from, to, message, timeout)

	if len(ret) == 0 {
		panic("no return value specified for RemoteAsk")
	}

	var r0 *anypb.Any
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *address.Address, *address.Address, protoreflect.ProtoMessage, time.Duration) (*anypb.Any, error)); ok {
		return rf(ctx, from, to, message, timeout)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *address.Address, *address.Address, protoreflect.ProtoMessage, time.Duration) *anypb.Any); ok {
		r0 = rf(ctx, from, to, message, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*anypb.Any)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *address.Address, *address.Address, protoreflect.ProtoMessage, time.Duration) error); ok {
		r1 = rf(ctx, from, to, message, timeout)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Remoting_RemoteAsk_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteAsk'
type Remoting_RemoteAsk_Call struct {
	*mock.Call
}

// RemoteAsk is a helper method to define mock.On call
//   - ctx context.Context
//   - from *address.Address
//   - to *address.Address
//   - message protoreflect.ProtoMessage
//   - timeout time.Duration
func (_e *Remoting_Expecter) RemoteAsk(ctx interface{}, from interface{}, to interface{}, message interface{}, timeout interface{}) *Remoting_RemoteAsk_Call {
	return &Remoting_RemoteAsk_Call{Call: _e.mock.On("RemoteAsk", ctx, from, to, message, timeout)}
}

func (_c *Remoting_RemoteAsk_Call) Run(run func(ctx context.Context, from *address.Address, to *address.Address, message protoreflect.ProtoMessage, timeout time.Duration)) *Remoting_RemoteAsk_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*address.Address), args[2].(*address.Address), args[3].(protoreflect.ProtoMessage), args[4].(time.Duration))
	})
	return _c
}

func (_c *Remoting_RemoteAsk_Call) Return(response *anypb.Any, err error) *Remoting_RemoteAsk_Call {
	_c.Call.Return(response, err)
	return _c
}

func (_c *Remoting_RemoteAsk_Call) RunAndReturn(run func(context.Context, *address.Address, *address.Address, protoreflect.ProtoMessage, time.Duration) (*anypb.Any, error)) *Remoting_RemoteAsk_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteBatchAsk provides a mock function with given fields: ctx, from, to, messages, timeout
func (_m *Remoting) RemoteBatchAsk(ctx context.Context, from *address.Address, to *address.Address, messages []protoreflect.ProtoMessage, timeout time.Duration) ([]*anypb.Any, error) {
	ret := _m.Called(ctx, from, to, messages, timeout)

	if len(ret) == 0 {
		panic("no return value specified for RemoteBatchAsk")
	}

	var r0 []*anypb.Any
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *address.Address, *address.Address, []protoreflect.ProtoMessage, time.Duration) ([]*anypb.Any, error)); ok {
		return rf(ctx, from, to, messages, timeout)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *address.Address, *address.Address, []protoreflect.ProtoMessage, time.Duration) []*anypb.Any); ok {
		r0 = rf(ctx, from, to, messages, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*anypb.Any)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *address.Address, *address.Address, []protoreflect.ProtoMessage, time.Duration) error); ok {
		r1 = rf(ctx, from, to, messages, timeout)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Remoting_RemoteBatchAsk_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteBatchAsk'
type Remoting_RemoteBatchAsk_Call struct {
	*mock.Call
}

// RemoteBatchAsk is a helper method to define mock.On call
//   - ctx context.Context
//   - from *address.Address
//   - to *address.Address
//   - messages []protoreflect.ProtoMessage
//   - timeout time.Duration
func (_e *Remoting_Expecter) RemoteBatchAsk(ctx interface{}, from interface{}, to interface{}, messages interface{}, timeout interface{}) *Remoting_RemoteBatchAsk_Call {
	return &Remoting_RemoteBatchAsk_Call{Call: _e.mock.On("RemoteBatchAsk", ctx, from, to, messages, timeout)}
}

func (_c *Remoting_RemoteBatchAsk_Call) Run(run func(ctx context.Context, from *address.Address, to *address.Address, messages []protoreflect.ProtoMessage, timeout time.Duration)) *Remoting_RemoteBatchAsk_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*address.Address), args[2].(*address.Address), args[3].([]protoreflect.ProtoMessage), args[4].(time.Duration))
	})
	return _c
}

func (_c *Remoting_RemoteBatchAsk_Call) Return(responses []*anypb.Any, err error) *Remoting_RemoteBatchAsk_Call {
	_c.Call.Return(responses, err)
	return _c
}

func (_c *Remoting_RemoteBatchAsk_Call) RunAndReturn(run func(context.Context, *address.Address, *address.Address, []protoreflect.ProtoMessage, time.Duration) ([]*anypb.Any, error)) *Remoting_RemoteBatchAsk_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteBatchTell provides a mock function with given fields: ctx, from, to, messages
func (_m *Remoting) RemoteBatchTell(ctx context.Context, from *address.Address, to *address.Address, messages []protoreflect.ProtoMessage) error {
	ret := _m.Called(ctx, from, to, messages)

	if len(ret) == 0 {
		panic("no return value specified for RemoteBatchTell")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *address.Address, *address.Address, []protoreflect.ProtoMessage) error); ok {
		r0 = rf(ctx, from, to, messages)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Remoting_RemoteBatchTell_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteBatchTell'
type Remoting_RemoteBatchTell_Call struct {
	*mock.Call
}

// RemoteBatchTell is a helper method to define mock.On call
//   - ctx context.Context
//   - from *address.Address
//   - to *address.Address
//   - messages []protoreflect.ProtoMessage
func (_e *Remoting_Expecter) RemoteBatchTell(ctx interface{}, from interface{}, to interface{}, messages interface{}) *Remoting_RemoteBatchTell_Call {
	return &Remoting_RemoteBatchTell_Call{Call: _e.mock.On("RemoteBatchTell", ctx, from, to, messages)}
}

func (_c *Remoting_RemoteBatchTell_Call) Run(run func(ctx context.Context, from *address.Address, to *address.Address, messages []protoreflect.ProtoMessage)) *Remoting_RemoteBatchTell_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*address.Address), args[2].(*address.Address), args[3].([]protoreflect.ProtoMessage))
	})
	return _c
}

func (_c *Remoting_RemoteBatchTell_Call) Return(_a0 error) *Remoting_RemoteBatchTell_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Remoting_RemoteBatchTell_Call) RunAndReturn(run func(context.Context, *address.Address, *address.Address, []protoreflect.ProtoMessage) error) *Remoting_RemoteBatchTell_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteLookup provides a mock function with given fields: ctx, host, port, name
func (_m *Remoting) RemoteLookup(ctx context.Context, host string, port int, name string) (*address.Address, error) {
	ret := _m.Called(ctx, host, port, name)

	if len(ret) == 0 {
		panic("no return value specified for RemoteLookup")
	}

	var r0 *address.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) (*address.Address, error)); ok {
		return rf(ctx, host, port, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) *address.Address); ok {
		r0 = rf(ctx, host, port, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*address.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, string) error); ok {
		r1 = rf(ctx, host, port, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Remoting_RemoteLookup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteLookup'
type Remoting_RemoteLookup_Call struct {
	*mock.Call
}

// RemoteLookup is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - name string
func (_e *Remoting_Expecter) RemoteLookup(ctx interface{}, host interface{}, port interface{}, name interface{}) *Remoting_RemoteLookup_Call {
	return &Remoting_RemoteLookup_Call{Call: _e.mock.On("RemoteLookup", ctx, host, port, name)}
}

func (_c *Remoting_RemoteLookup_Call) Run(run func(ctx context.Context, host string, port int, name string)) *Remoting_RemoteLookup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *Remoting_RemoteLookup_Call) Return(addr *address.Address, err error) *Remoting_RemoteLookup_Call {
	_c.Call.Return(addr, err)
	return _c
}

func (_c *Remoting_RemoteLookup_Call) RunAndReturn(run func(context.Context, string, int, string) (*address.Address, error)) *Remoting_RemoteLookup_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteReSpawn provides a mock function with given fields: ctx, host, port, name
func (_m *Remoting) RemoteReSpawn(ctx context.Context, host string, port int, name string) error {
	ret := _m.Called(ctx, host, port, name)

	if len(ret) == 0 {
		panic("no return value specified for RemoteReSpawn")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) error); ok {
		r0 = rf(ctx, host, port, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Remoting_RemoteReSpawn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteReSpawn'
type Remoting_RemoteReSpawn_Call struct {
	*mock.Call
}

// RemoteReSpawn is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - name string
func (_e *Remoting_Expecter) RemoteReSpawn(ctx interface{}, host interface{}, port interface{}, name interface{}) *Remoting_RemoteReSpawn_Call {
	return &Remoting_RemoteReSpawn_Call{Call: _e.mock.On("RemoteReSpawn", ctx, host, port, name)}
}

func (_c *Remoting_RemoteReSpawn_Call) Run(run func(ctx context.Context, host string, port int, name string)) *Remoting_RemoteReSpawn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *Remoting_RemoteReSpawn_Call) Return(_a0 error) *Remoting_RemoteReSpawn_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Remoting_RemoteReSpawn_Call) RunAndReturn(run func(context.Context, string, int, string) error) *Remoting_RemoteReSpawn_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteReinstate provides a mock function with given fields: ctx, host, port, name
func (_m *Remoting) RemoteReinstate(ctx context.Context, host string, port int, name string) error {
	ret := _m.Called(ctx, host, port, name)

	if len(ret) == 0 {
		panic("no return value specified for RemoteReinstate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) error); ok {
		r0 = rf(ctx, host, port, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Remoting_RemoteReinstate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteReinstate'
type Remoting_RemoteReinstate_Call struct {
	*mock.Call
}

// RemoteReinstate is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - name string
func (_e *Remoting_Expecter) RemoteReinstate(ctx interface{}, host interface{}, port interface{}, name interface{}) *Remoting_RemoteReinstate_Call {
	return &Remoting_RemoteReinstate_Call{Call: _e.mock.On("RemoteReinstate", ctx, host, port, name)}
}

func (_c *Remoting_RemoteReinstate_Call) Run(run func(ctx context.Context, host string, port int, name string)) *Remoting_RemoteReinstate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *Remoting_RemoteReinstate_Call) Return(_a0 error) *Remoting_RemoteReinstate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Remoting_RemoteReinstate_Call) RunAndReturn(run func(context.Context, string, int, string) error) *Remoting_RemoteReinstate_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteSpawn provides a mock function with given fields: ctx, host, port, spawnRequest
func (_m *Remoting) RemoteSpawn(ctx context.Context, host string, port int, spawnRequest *v3remote.SpawnRequest) error {
	ret := _m.Called(ctx, host, port, spawnRequest)

	if len(ret) == 0 {
		panic("no return value specified for RemoteSpawn")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *v3remote.SpawnRequest) error); ok {
		r0 = rf(ctx, host, port, spawnRequest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Remoting_RemoteSpawn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteSpawn'
type Remoting_RemoteSpawn_Call struct {
	*mock.Call
}

// RemoteSpawn is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - spawnRequest *v3remote.SpawnRequest
func (_e *Remoting_Expecter) RemoteSpawn(ctx interface{}, host interface{}, port interface{}, spawnRequest interface{}) *Remoting_RemoteSpawn_Call {
	return &Remoting_RemoteSpawn_Call{Call: _e.mock.On("RemoteSpawn", ctx, host, port, spawnRequest)}
}

func (_c *Remoting_RemoteSpawn_Call) Run(run func(ctx context.Context, host string, port int, spawnRequest *v3remote.SpawnRequest)) *Remoting_RemoteSpawn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(*v3remote.SpawnRequest))
	})
	return _c
}

func (_c *Remoting_RemoteSpawn_Call) Return(_a0 error) *Remoting_RemoteSpawn_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Remoting_RemoteSpawn_Call) RunAndReturn(run func(context.Context, string, int, *v3remote.SpawnRequest) error) *Remoting_RemoteSpawn_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteStop provides a mock function with given fields: ctx, host, port, name
func (_m *Remoting) RemoteStop(ctx context.Context, host string, port int, name string) error {
	ret := _m.Called(ctx, host, port, name)

	if len(ret) == 0 {
		panic("no return value specified for RemoteStop")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) error); ok {
		r0 = rf(ctx, host, port, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Remoting_RemoteStop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteStop'
type Remoting_RemoteStop_Call struct {
	*mock.Call
}

// RemoteStop is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - name string
func (_e *Remoting_Expecter) RemoteStop(ctx interface{}, host interface{}, port interface{}, name interface{}) *Remoting_RemoteStop_Call {
	return &Remoting_RemoteStop_Call{Call: _e.mock.On("RemoteStop", ctx, host, port, name)}
}

func (_c *Remoting_RemoteStop_Call) Run(run func(ctx context.Context, host string, port int, name string)) *Remoting_RemoteStop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *Remoting_RemoteStop_Call) Return(_a0 error) *Remoting_RemoteStop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Remoting_RemoteStop_Call) RunAndReturn(run func(context.Context, string, int, string) error) *Remoting_RemoteStop_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteTell provides a mock function with given fields: ctx, from, to, message
func (_m *Remoting) RemoteTell(ctx context.Context, from *address.Address, to *address.Address, message protoreflect.ProtoMessage) error {
	ret := _m.Called(ctx, from, to, message)

	if len(ret) == 0 {
		panic("no return value specified for RemoteTell")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *address.Address, *address.Address, protoreflect.ProtoMessage) error); ok {
		r0 = rf(ctx, from, to, message)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Remoting_RemoteTell_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteTell'
type Remoting_RemoteTell_Call struct {
	*mock.Call
}

// RemoteTell is a helper method to define mock.On call
//   - ctx context.Context
//   - from *address.Address
//   - to *address.Address
//   - message protoreflect.ProtoMessage
func (_e *Remoting_Expecter) RemoteTell(ctx interface{}, from interface{}, to interface{}, message interface{}) *Remoting_RemoteTell_Call {
	return &Remoting_RemoteTell_Call{Call: _e.mock.On("RemoteTell", ctx, from, to, message)}
}

func (_c *Remoting_RemoteTell_Call) Run(run func(ctx context.Context, from *address.Address, to *address.Address, message protoreflect.ProtoMessage)) *Remoting_RemoteTell_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*address.Address), args[2].(*address.Address), args[3].(protoreflect.ProtoMessage))
	})
	return _c
}

func (_c *Remoting_RemoteTell_Call) Return(_a0 error) *Remoting_RemoteTell_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Remoting_RemoteTell_Call) RunAndReturn(run func(context.Context, *address.Address, *address.Address, protoreflect.ProtoMessage) error) *Remoting_RemoteTell_Call {
	_c.Call.Return(run)
	return _c
}

// RemotingServiceClient provides a mock function with given fields: host, port
func (_m *Remoting) RemotingServiceClient(host string, port int) internalpbconnect.RemotingServiceClient {
	ret := _m.Called(host, port)

	if len(ret) == 0 {
		panic("no return value specified for RemotingServiceClient")
	}

	var r0 internalpbconnect.RemotingServiceClient
	if rf, ok := ret.Get(0).(func(string, int) internalpbconnect.RemotingServiceClient); ok {
		r0 = rf(host, port)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(internalpbconnect.RemotingServiceClient)
		}
	}

	return r0
}

// Remoting_RemotingServiceClient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemotingServiceClient'
type Remoting_RemotingServiceClient_Call struct {
	*mock.Call
}

// RemotingServiceClient is a helper method to define mock.On call
//   - host string
//   - port int
func (_e *Remoting_Expecter) RemotingServiceClient(host interface{}, port interface{}) *Remoting_RemotingServiceClient_Call {
	return &Remoting_RemotingServiceClient_Call{Call: _e.mock.On("RemotingServiceClient", host, port)}
}

func (_c *Remoting_RemotingServiceClient_Call) Run(run func(host string, port int)) *Remoting_RemotingServiceClient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(int))
	})
	return _c
}

func (_c *Remoting_RemotingServiceClient_Call) Return(_a0 internalpbconnect.RemotingServiceClient) *Remoting_RemotingServiceClient_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Remoting_RemotingServiceClient_Call) RunAndReturn(run func(string, int) internalpbconnect.RemotingServiceClient) *Remoting_RemotingServiceClient_Call {
	_c.Call.Return(run)
	return _c
}

// NewRemoting creates a new instance of Remoting. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRemoting(t interface {
	mock.TestingT
	Cleanup(func())
}) *Remoting {
	mock := &Remoting{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
