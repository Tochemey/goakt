// Code generated by mockery. DO NOT EDIT.

package remote

import (
	context "context"
	tls "crypto/tls"
	time "time"

	mock "github.com/stretchr/testify/mock"
	address "github.com/tochemey/goakt/v4/address"
	net "github.com/tochemey/goakt/v4/internal/net"
	v4remote "github.com/tochemey/goakt/v4/remote"
)

// Remoting is an autogenerated mock type for the Remoting type
type Remoting struct {
	mock.Mock
}

type Remoting_Expecter struct {
	mock *mock.Mock
}

func (_m *Remoting) EXPECT() *Remoting_Expecter {
	return &Remoting_Expecter{mock: &_m.Mock}
}

// Close provides a mock function with no fields
func (_m *Remoting) Close() {
	_m.Called()
}

// Remoting_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type Remoting_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *Remoting_Expecter) Close() *Remoting_Close_Call {
	return &Remoting_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *Remoting_Close_Call) Run(run func()) *Remoting_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Remoting_Close_Call) Return() *Remoting_Close_Call {
	_c.Call.Return()
	return _c
}

func (_c *Remoting_Close_Call) RunAndReturn(run func()) *Remoting_Close_Call {
	_c.Run(run)
	return _c
}

// Compression provides a mock function with no fields
func (_m *Remoting) Compression() v4remote.Compression {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Compression")
	}

	var r0 v4remote.Compression
	if rf, ok := ret.Get(0).(func() v4remote.Compression); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(v4remote.Compression)
	}

	return r0
}

// Remoting_Compression_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Compression'
type Remoting_Compression_Call struct {
	*mock.Call
}

// Compression is a helper method to define mock.On call
func (_e *Remoting_Expecter) Compression() *Remoting_Compression_Call {
	return &Remoting_Compression_Call{Call: _e.mock.On("Compression")}
}

func (_c *Remoting_Compression_Call) Run(run func()) *Remoting_Compression_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Remoting_Compression_Call) Return(_a0 v4remote.Compression) *Remoting_Compression_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Remoting_Compression_Call) RunAndReturn(run func() v4remote.Compression) *Remoting_Compression_Call {
	_c.Call.Return(run)
	return _c
}

// NetClient provides a mock function with given fields: host, port
func (_m *Remoting) NetClient(host string, port int) *net.Client {
	ret := _m.Called(host, port)

	if len(ret) == 0 {
		panic("no return value specified for NetClient")
	}

	var r0 *net.Client
	if rf, ok := ret.Get(0).(func(string, int) *net.Client); ok {
		r0 = rf(host, port)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*net.Client)
		}
	}

	return r0
}

// Remoting_NetClient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetClient'
type Remoting_NetClient_Call struct {
	*mock.Call
}

// NetClient is a helper method to define mock.On call
//   - host string
//   - port int
func (_e *Remoting_Expecter) NetClient(host interface{}, port interface{}) *Remoting_NetClient_Call {
	return &Remoting_NetClient_Call{Call: _e.mock.On("NetClient", host, port)}
}

func (_c *Remoting_NetClient_Call) Run(run func(host string, port int)) *Remoting_NetClient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(int))
	})
	return _c
}

func (_c *Remoting_NetClient_Call) Return(_a0 *net.Client) *Remoting_NetClient_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Remoting_NetClient_Call) RunAndReturn(run func(string, int) *net.Client) *Remoting_NetClient_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteActivateGrain provides a mock function with given fields: ctx, host, port, grainRequest
func (_m *Remoting) RemoteActivateGrain(ctx context.Context, host string, port int, grainRequest *v4remote.GrainRequest) error {
	ret := _m.Called(ctx, host, port, grainRequest)

	if len(ret) == 0 {
		panic("no return value specified for RemoteActivateGrain")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *v4remote.GrainRequest) error); ok {
		r0 = rf(ctx, host, port, grainRequest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Remoting_RemoteActivateGrain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteActivateGrain'
type Remoting_RemoteActivateGrain_Call struct {
	*mock.Call
}

// RemoteActivateGrain is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - grainRequest *v4remote.GrainRequest
func (_e *Remoting_Expecter) RemoteActivateGrain(ctx interface{}, host interface{}, port interface{}, grainRequest interface{}) *Remoting_RemoteActivateGrain_Call {
	return &Remoting_RemoteActivateGrain_Call{Call: _e.mock.On("RemoteActivateGrain", ctx, host, port, grainRequest)}
}

func (_c *Remoting_RemoteActivateGrain_Call) Run(run func(ctx context.Context, host string, port int, grainRequest *v4remote.GrainRequest)) *Remoting_RemoteActivateGrain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(*v4remote.GrainRequest))
	})
	return _c
}

func (_c *Remoting_RemoteActivateGrain_Call) Return(_a0 error) *Remoting_RemoteActivateGrain_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Remoting_RemoteActivateGrain_Call) RunAndReturn(run func(context.Context, string, int, *v4remote.GrainRequest) error) *Remoting_RemoteActivateGrain_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteAsk provides a mock function with given fields: ctx, from, to, message, timeout
func (_m *Remoting) RemoteAsk(ctx context.Context, from *address.Address, to *address.Address, message interface{}, timeout time.Duration) (interface{}, error) {
	ret := _m.Called(ctx, from, to, message, timeout)

	if len(ret) == 0 {
		panic("no return value specified for RemoteAsk")
	}

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *address.Address, *address.Address, interface{}, time.Duration) (interface{}, error)); ok {
		return rf(ctx, from, to, message, timeout)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *address.Address, *address.Address, interface{}, time.Duration) interface{}); ok {
		r0 = rf(ctx, from, to, message, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *address.Address, *address.Address, interface{}, time.Duration) error); ok {
		r1 = rf(ctx, from, to, message, timeout)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Remoting_RemoteAsk_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteAsk'
type Remoting_RemoteAsk_Call struct {
	*mock.Call
}

// RemoteAsk is a helper method to define mock.On call
//   - ctx context.Context
//   - from *address.Address
//   - to *address.Address
//   - message interface{}
//   - timeout time.Duration
func (_e *Remoting_Expecter) RemoteAsk(ctx interface{}, from interface{}, to interface{}, message interface{}, timeout interface{}) *Remoting_RemoteAsk_Call {
	return &Remoting_RemoteAsk_Call{Call: _e.mock.On("RemoteAsk", ctx, from, to, message, timeout)}
}

func (_c *Remoting_RemoteAsk_Call) Run(run func(ctx context.Context, from *address.Address, to *address.Address, message interface{}, timeout time.Duration)) *Remoting_RemoteAsk_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*address.Address), args[2].(*address.Address), args[3].(interface{}), args[4].(time.Duration))
	})
	return _c
}

func (_c *Remoting_RemoteAsk_Call) Return(response interface{}, err error) *Remoting_RemoteAsk_Call {
	_c.Call.Return(response, err)
	return _c
}

func (_c *Remoting_RemoteAsk_Call) RunAndReturn(run func(context.Context, *address.Address, *address.Address, interface{}, time.Duration) (interface{}, error)) *Remoting_RemoteAsk_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteAskGrain provides a mock function with given fields: ctx, host, port, grainRequest, message, timeout
func (_m *Remoting) RemoteAskGrain(ctx context.Context, host string, port int, grainRequest *v4remote.GrainRequest, message interface{}, timeout time.Duration) (interface{}, error) {
	ret := _m.Called(ctx, host, port, grainRequest, message, timeout)

	if len(ret) == 0 {
		panic("no return value specified for RemoteAskGrain")
	}

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *v4remote.GrainRequest, interface{}, time.Duration) (interface{}, error)); ok {
		return rf(ctx, host, port, grainRequest, message, timeout)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *v4remote.GrainRequest, interface{}, time.Duration) interface{}); ok {
		r0 = rf(ctx, host, port, grainRequest, message, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, *v4remote.GrainRequest, interface{}, time.Duration) error); ok {
		r1 = rf(ctx, host, port, grainRequest, message, timeout)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Remoting_RemoteAskGrain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteAskGrain'
type Remoting_RemoteAskGrain_Call struct {
	*mock.Call
}

// RemoteAskGrain is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - grainRequest *v4remote.GrainRequest
//   - message interface{}
//   - timeout time.Duration
func (_e *Remoting_Expecter) RemoteAskGrain(ctx interface{}, host interface{}, port interface{}, grainRequest interface{}, message interface{}, timeout interface{}) *Remoting_RemoteAskGrain_Call {
	return &Remoting_RemoteAskGrain_Call{Call: _e.mock.On("RemoteAskGrain", ctx, host, port, grainRequest, message, timeout)}
}

func (_c *Remoting_RemoteAskGrain_Call) Run(run func(ctx context.Context, host string, port int, grainRequest *v4remote.GrainRequest, message interface{}, timeout time.Duration)) *Remoting_RemoteAskGrain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(*v4remote.GrainRequest), args[4].(interface{}), args[5].(time.Duration))
	})
	return _c
}

func (_c *Remoting_RemoteAskGrain_Call) Return(response interface{}, err error) *Remoting_RemoteAskGrain_Call {
	_c.Call.Return(response, err)
	return _c
}

func (_c *Remoting_RemoteAskGrain_Call) RunAndReturn(run func(context.Context, string, int, *v4remote.GrainRequest, interface{}, time.Duration) (interface{}, error)) *Remoting_RemoteAskGrain_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteBatchAsk provides a mock function with given fields: ctx, from, to, messages, timeout
func (_m *Remoting) RemoteBatchAsk(ctx context.Context, from *address.Address, to *address.Address, messages []interface{}, timeout time.Duration) ([]interface{}, error) {
	ret := _m.Called(ctx, from, to, messages, timeout)

	if len(ret) == 0 {
		panic("no return value specified for RemoteBatchAsk")
	}

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *address.Address, *address.Address, []interface{}, time.Duration) ([]interface{}, error)); ok {
		return rf(ctx, from, to, messages, timeout)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *address.Address, *address.Address, []interface{}, time.Duration) []interface{}); ok {
		r0 = rf(ctx, from, to, messages, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *address.Address, *address.Address, []interface{}, time.Duration) error); ok {
		r1 = rf(ctx, from, to, messages, timeout)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Remoting_RemoteBatchAsk_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteBatchAsk'
type Remoting_RemoteBatchAsk_Call struct {
	*mock.Call
}

// RemoteBatchAsk is a helper method to define mock.On call
//   - ctx context.Context
//   - from *address.Address
//   - to *address.Address
//   - messages []interface{}
//   - timeout time.Duration
func (_e *Remoting_Expecter) RemoteBatchAsk(ctx interface{}, from interface{}, to interface{}, messages interface{}, timeout interface{}) *Remoting_RemoteBatchAsk_Call {
	return &Remoting_RemoteBatchAsk_Call{Call: _e.mock.On("RemoteBatchAsk", ctx, from, to, messages, timeout)}
}

func (_c *Remoting_RemoteBatchAsk_Call) Run(run func(ctx context.Context, from *address.Address, to *address.Address, messages []interface{}, timeout time.Duration)) *Remoting_RemoteBatchAsk_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*address.Address), args[2].(*address.Address), args[3].([]interface{}), args[4].(time.Duration))
	})
	return _c
}

func (_c *Remoting_RemoteBatchAsk_Call) Return(responses []interface{}, err error) *Remoting_RemoteBatchAsk_Call {
	_c.Call.Return(responses, err)
	return _c
}

func (_c *Remoting_RemoteBatchAsk_Call) RunAndReturn(run func(context.Context, *address.Address, *address.Address, []interface{}, time.Duration) ([]interface{}, error)) *Remoting_RemoteBatchAsk_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteBatchTell provides a mock function with given fields: ctx, from, to, messages
func (_m *Remoting) RemoteBatchTell(ctx context.Context, from *address.Address, to *address.Address, messages []interface{}) error {
	ret := _m.Called(ctx, from, to, messages)

	if len(ret) == 0 {
		panic("no return value specified for RemoteBatchTell")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *address.Address, *address.Address, []interface{}) error); ok {
		r0 = rf(ctx, from, to, messages)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Remoting_RemoteBatchTell_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteBatchTell'
type Remoting_RemoteBatchTell_Call struct {
	*mock.Call
}

// RemoteBatchTell is a helper method to define mock.On call
//   - ctx context.Context
//   - from *address.Address
//   - to *address.Address
//   - messages []interface{}
func (_e *Remoting_Expecter) RemoteBatchTell(ctx interface{}, from interface{}, to interface{}, messages interface{}) *Remoting_RemoteBatchTell_Call {
	return &Remoting_RemoteBatchTell_Call{Call: _e.mock.On("RemoteBatchTell", ctx, from, to, messages)}
}

func (_c *Remoting_RemoteBatchTell_Call) Run(run func(ctx context.Context, from *address.Address, to *address.Address, messages []interface{})) *Remoting_RemoteBatchTell_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*address.Address), args[2].(*address.Address), args[3].([]interface{}))
	})
	return _c
}

func (_c *Remoting_RemoteBatchTell_Call) Return(_a0 error) *Remoting_RemoteBatchTell_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Remoting_RemoteBatchTell_Call) RunAndReturn(run func(context.Context, *address.Address, *address.Address, []interface{}) error) *Remoting_RemoteBatchTell_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteLookup provides a mock function with given fields: ctx, host, port, name
func (_m *Remoting) RemoteLookup(ctx context.Context, host string, port int, name string) (*address.Address, error) {
	ret := _m.Called(ctx, host, port, name)

	if len(ret) == 0 {
		panic("no return value specified for RemoteLookup")
	}

	var r0 *address.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) (*address.Address, error)); ok {
		return rf(ctx, host, port, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) *address.Address); ok {
		r0 = rf(ctx, host, port, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*address.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, string) error); ok {
		r1 = rf(ctx, host, port, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Remoting_RemoteLookup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteLookup'
type Remoting_RemoteLookup_Call struct {
	*mock.Call
}

// RemoteLookup is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - name string
func (_e *Remoting_Expecter) RemoteLookup(ctx interface{}, host interface{}, port interface{}, name interface{}) *Remoting_RemoteLookup_Call {
	return &Remoting_RemoteLookup_Call{Call: _e.mock.On("RemoteLookup", ctx, host, port, name)}
}

func (_c *Remoting_RemoteLookup_Call) Run(run func(ctx context.Context, host string, port int, name string)) *Remoting_RemoteLookup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *Remoting_RemoteLookup_Call) Return(addr *address.Address, err error) *Remoting_RemoteLookup_Call {
	_c.Call.Return(addr, err)
	return _c
}

func (_c *Remoting_RemoteLookup_Call) RunAndReturn(run func(context.Context, string, int, string) (*address.Address, error)) *Remoting_RemoteLookup_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteReSpawn provides a mock function with given fields: ctx, host, port, name
func (_m *Remoting) RemoteReSpawn(ctx context.Context, host string, port int, name string) error {
	ret := _m.Called(ctx, host, port, name)

	if len(ret) == 0 {
		panic("no return value specified for RemoteReSpawn")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) error); ok {
		r0 = rf(ctx, host, port, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Remoting_RemoteReSpawn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteReSpawn'
type Remoting_RemoteReSpawn_Call struct {
	*mock.Call
}

// RemoteReSpawn is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - name string
func (_e *Remoting_Expecter) RemoteReSpawn(ctx interface{}, host interface{}, port interface{}, name interface{}) *Remoting_RemoteReSpawn_Call {
	return &Remoting_RemoteReSpawn_Call{Call: _e.mock.On("RemoteReSpawn", ctx, host, port, name)}
}

func (_c *Remoting_RemoteReSpawn_Call) Run(run func(ctx context.Context, host string, port int, name string)) *Remoting_RemoteReSpawn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *Remoting_RemoteReSpawn_Call) Return(_a0 error) *Remoting_RemoteReSpawn_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Remoting_RemoteReSpawn_Call) RunAndReturn(run func(context.Context, string, int, string) error) *Remoting_RemoteReSpawn_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteReinstate provides a mock function with given fields: ctx, host, port, name
func (_m *Remoting) RemoteReinstate(ctx context.Context, host string, port int, name string) error {
	ret := _m.Called(ctx, host, port, name)

	if len(ret) == 0 {
		panic("no return value specified for RemoteReinstate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) error); ok {
		r0 = rf(ctx, host, port, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Remoting_RemoteReinstate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteReinstate'
type Remoting_RemoteReinstate_Call struct {
	*mock.Call
}

// RemoteReinstate is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - name string
func (_e *Remoting_Expecter) RemoteReinstate(ctx interface{}, host interface{}, port interface{}, name interface{}) *Remoting_RemoteReinstate_Call {
	return &Remoting_RemoteReinstate_Call{Call: _e.mock.On("RemoteReinstate", ctx, host, port, name)}
}

func (_c *Remoting_RemoteReinstate_Call) Run(run func(ctx context.Context, host string, port int, name string)) *Remoting_RemoteReinstate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *Remoting_RemoteReinstate_Call) Return(_a0 error) *Remoting_RemoteReinstate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Remoting_RemoteReinstate_Call) RunAndReturn(run func(context.Context, string, int, string) error) *Remoting_RemoteReinstate_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteSpawn provides a mock function with given fields: ctx, host, port, spawnRequest
func (_m *Remoting) RemoteSpawn(ctx context.Context, host string, port int, spawnRequest *v4remote.SpawnRequest) error {
	ret := _m.Called(ctx, host, port, spawnRequest)

	if len(ret) == 0 {
		panic("no return value specified for RemoteSpawn")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *v4remote.SpawnRequest) error); ok {
		r0 = rf(ctx, host, port, spawnRequest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Remoting_RemoteSpawn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteSpawn'
type Remoting_RemoteSpawn_Call struct {
	*mock.Call
}

// RemoteSpawn is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - spawnRequest *v4remote.SpawnRequest
func (_e *Remoting_Expecter) RemoteSpawn(ctx interface{}, host interface{}, port interface{}, spawnRequest interface{}) *Remoting_RemoteSpawn_Call {
	return &Remoting_RemoteSpawn_Call{Call: _e.mock.On("RemoteSpawn", ctx, host, port, spawnRequest)}
}

func (_c *Remoting_RemoteSpawn_Call) Run(run func(ctx context.Context, host string, port int, spawnRequest *v4remote.SpawnRequest)) *Remoting_RemoteSpawn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(*v4remote.SpawnRequest))
	})
	return _c
}

func (_c *Remoting_RemoteSpawn_Call) Return(_a0 error) *Remoting_RemoteSpawn_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Remoting_RemoteSpawn_Call) RunAndReturn(run func(context.Context, string, int, *v4remote.SpawnRequest) error) *Remoting_RemoteSpawn_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteStop provides a mock function with given fields: ctx, host, port, name
func (_m *Remoting) RemoteStop(ctx context.Context, host string, port int, name string) error {
	ret := _m.Called(ctx, host, port, name)

	if len(ret) == 0 {
		panic("no return value specified for RemoteStop")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, string) error); ok {
		r0 = rf(ctx, host, port, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Remoting_RemoteStop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteStop'
type Remoting_RemoteStop_Call struct {
	*mock.Call
}

// RemoteStop is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - name string
func (_e *Remoting_Expecter) RemoteStop(ctx interface{}, host interface{}, port interface{}, name interface{}) *Remoting_RemoteStop_Call {
	return &Remoting_RemoteStop_Call{Call: _e.mock.On("RemoteStop", ctx, host, port, name)}
}

func (_c *Remoting_RemoteStop_Call) Run(run func(ctx context.Context, host string, port int, name string)) *Remoting_RemoteStop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(string))
	})
	return _c
}

func (_c *Remoting_RemoteStop_Call) Return(_a0 error) *Remoting_RemoteStop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Remoting_RemoteStop_Call) RunAndReturn(run func(context.Context, string, int, string) error) *Remoting_RemoteStop_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteTell provides a mock function with given fields: ctx, from, to, message
func (_m *Remoting) RemoteTell(ctx context.Context, from *address.Address, to *address.Address, message interface{}) error {
	ret := _m.Called(ctx, from, to, message)

	if len(ret) == 0 {
		panic("no return value specified for RemoteTell")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *address.Address, *address.Address, interface{}) error); ok {
		r0 = rf(ctx, from, to, message)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Remoting_RemoteTell_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteTell'
type Remoting_RemoteTell_Call struct {
	*mock.Call
}

// RemoteTell is a helper method to define mock.On call
//   - ctx context.Context
//   - from *address.Address
//   - to *address.Address
//   - message interface{}
func (_e *Remoting_Expecter) RemoteTell(ctx interface{}, from interface{}, to interface{}, message interface{}) *Remoting_RemoteTell_Call {
	return &Remoting_RemoteTell_Call{Call: _e.mock.On("RemoteTell", ctx, from, to, message)}
}

func (_c *Remoting_RemoteTell_Call) Run(run func(ctx context.Context, from *address.Address, to *address.Address, message interface{})) *Remoting_RemoteTell_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*address.Address), args[2].(*address.Address), args[3].(interface{}))
	})
	return _c
}

func (_c *Remoting_RemoteTell_Call) Return(_a0 error) *Remoting_RemoteTell_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Remoting_RemoteTell_Call) RunAndReturn(run func(context.Context, *address.Address, *address.Address, interface{}) error) *Remoting_RemoteTell_Call {
	_c.Call.Return(run)
	return _c
}

// RemoteTellGrain provides a mock function with given fields: ctx, host, port, grainRequest, message
func (_m *Remoting) RemoteTellGrain(ctx context.Context, host string, port int, grainRequest *v4remote.GrainRequest, message interface{}) error {
	ret := _m.Called(ctx, host, port, grainRequest, message)

	if len(ret) == 0 {
		panic("no return value specified for RemoteTellGrain")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *v4remote.GrainRequest, interface{}) error); ok {
		r0 = rf(ctx, host, port, grainRequest, message)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Remoting_RemoteTellGrain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoteTellGrain'
type Remoting_RemoteTellGrain_Call struct {
	*mock.Call
}

// RemoteTellGrain is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port int
//   - grainRequest *v4remote.GrainRequest
//   - message interface{}
func (_e *Remoting_Expecter) RemoteTellGrain(ctx interface{}, host interface{}, port interface{}, grainRequest interface{}, message interface{}) *Remoting_RemoteTellGrain_Call {
	return &Remoting_RemoteTellGrain_Call{Call: _e.mock.On("RemoteTellGrain", ctx, host, port, grainRequest, message)}
}

func (_c *Remoting_RemoteTellGrain_Call) Run(run func(ctx context.Context, host string, port int, grainRequest *v4remote.GrainRequest, message interface{})) *Remoting_RemoteTellGrain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(*v4remote.GrainRequest), args[4].(interface{}))
	})
	return _c
}

func (_c *Remoting_RemoteTellGrain_Call) Return(_a0 error) *Remoting_RemoteTellGrain_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Remoting_RemoteTellGrain_Call) RunAndReturn(run func(context.Context, string, int, *v4remote.GrainRequest, interface{}) error) *Remoting_RemoteTellGrain_Call {
	_c.Call.Return(run)
	return _c
}

// Serializer provides a mock function with given fields: msg
func (_m *Remoting) Serializer(msg interface{}) v4remote.Serializer {
	ret := _m.Called(msg)

	if len(ret) == 0 {
		panic("no return value specified for Serializer")
	}

	var r0 v4remote.Serializer
	if rf, ok := ret.Get(0).(func(interface{}) v4remote.Serializer); ok {
		r0 = rf(msg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(v4remote.Serializer)
		}
	}

	return r0
}

// Remoting_Serializer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Serializer'
type Remoting_Serializer_Call struct {
	*mock.Call
}

// Serializer is a helper method to define mock.On call
//   - msg interface{}
func (_e *Remoting_Expecter) Serializer(msg interface{}) *Remoting_Serializer_Call {
	return &Remoting_Serializer_Call{Call: _e.mock.On("Serializer", msg)}
}

func (_c *Remoting_Serializer_Call) Run(run func(msg interface{})) *Remoting_Serializer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *Remoting_Serializer_Call) Return(_a0 v4remote.Serializer) *Remoting_Serializer_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Remoting_Serializer_Call) RunAndReturn(run func(interface{}) v4remote.Serializer) *Remoting_Serializer_Call {
	_c.Call.Return(run)
	return _c
}

// TLSConfig provides a mock function with no fields
func (_m *Remoting) TLSConfig() *tls.Config {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for TLSConfig")
	}

	var r0 *tls.Config
	if rf, ok := ret.Get(0).(func() *tls.Config); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tls.Config)
		}
	}

	return r0
}

// Remoting_TLSConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TLSConfig'
type Remoting_TLSConfig_Call struct {
	*mock.Call
}

// TLSConfig is a helper method to define mock.On call
func (_e *Remoting_Expecter) TLSConfig() *Remoting_TLSConfig_Call {
	return &Remoting_TLSConfig_Call{Call: _e.mock.On("TLSConfig")}
}

func (_c *Remoting_TLSConfig_Call) Run(run func()) *Remoting_TLSConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Remoting_TLSConfig_Call) Return(_a0 *tls.Config) *Remoting_TLSConfig_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Remoting_TLSConfig_Call) RunAndReturn(run func() *tls.Config) *Remoting_TLSConfig_Call {
	_c.Call.Return(run)
	return _c
}

// NewRemoting creates a new instance of Remoting. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRemoting(t interface {
	mock.TestingT
	Cleanup(func())
}) *Remoting {
	mock := &Remoting{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
