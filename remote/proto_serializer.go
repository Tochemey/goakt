// MIT License
//
// Copyright (c) 2022-2026 GoAkt Team
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package remote

import (
	"encoding/binary"
	"errors"
	"unsafe"

	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/reflect/protoregistry"
)

// ProtoSerializer errors.
var (
	// ErrNotProtoMessage is returned by [ProtoSerializer.Serialize] when the
	// supplied value does not implement [proto.Message]. All messages sent
	// through the remoting layer must be concrete protobuf types.
	ErrNotProtoMessage = errors.New("remote: message must implement proto.Message")

	// ErrUnknownMessageType is returned when the type name embedded in a frame
	// cannot be resolved to a registered [proto.Message] type. This typically
	// means the receiving node does not have the proto descriptor compiled in.
	ErrUnknownMessageType = errors.New("remote: unknown or unregistered proto message type")

	// ErrSerializeFailed is returned when protobuf marshaling fails. It wraps
	// the underlying proto library error.
	ErrSerializeFailed = errors.New("remote: failed to serialize proto message")

	// ErrDeserializeFailed is returned when protobuf unmarshaling fails. It
	// wraps the underlying proto library error.
	ErrDeserializeFailed = errors.New("remote: failed to deserialize proto message")

	// ErrInvalidFrame is returned when [ProtoSerializer.Deserialize] receives
	// a byte slice that is too short or whose length header fields are
	// inconsistent with the actual payload size.
	ErrInvalidFrame = errors.New("remote: malformed or truncated proto frame")
)

// ProtoSerializer is the built-in [Serializer] implementation provided by
// GoAkt. It encodes and decodes [proto.Message] values using a length-prefixed,
// self-describing binary frame format that embeds the message's fully-qualified
// type name so the receiver can reconstruct the correct concrete Go type at
// runtime via [protoregistry.GlobalTypes].
//
// # Frame layout
//
// All integers are big-endian uint32:
//
//	┌──────────┬──────────┬────────────┬──────────────┐
//	│ totalLen │ nameLen  │ type name  │ proto bytes  │
//	│ 4 bytes  │ 4 bytes  │ N bytes    │ M bytes      │
//	└──────────┴──────────┴────────────┴──────────────┘
//
//	totalLen = 4 + 4 + N + M   (covers the entire frame including itself)
//
// # Usage
//
// ProtoSerializer is stateless and safe for concurrent use. A single instance
// can be shared across goroutines without synchronization.
//
// Pass it to the remoting layer when configuring the actor system:
//
//	remoteCfg := remote.NewConfig("0.0.0.0", 9000,
//	    remote.WithSerializer(remote.NewProtoSerializer()),
//	)
//
// # Constraints
//
// Both [Serialize] and [Deserialize] require that the message type is
// registered in the global protobuf registry ([protoregistry.GlobalTypes]).
// Types generated by protoc-gen-go are registered automatically via their
// init functions; custom or dynamically constructed types must be registered
// explicitly.
type ProtoSerializer struct{}

// enforce the Serializer interface at compile time.
var _ Serializer = (*ProtoSerializer)(nil)

// NewProtoSerializer returns a ready-to-use [ProtoSerializer].
func NewProtoSerializer() *ProtoSerializer {
	return &ProtoSerializer{}
}

// Serialize implements [Serializer]. It type-asserts message to [proto.Message],
// then encodes it into a self-describing binary frame. The frame embeds the
// message's fully-qualified type name so [Deserialize] can resolve the concrete
// Go type without any out-of-band coordination.
//
// The encoding uses a single allocation by pre-computing the exact frame size
// via [proto.Size], writing both uint32 header fields from a stack-allocated
// array, and appending the proto wire bytes in-place — no intermediate buffers.
//
// Returns [ErrNotProtoMessage] if message does not implement [proto.Message].
// Returns [ErrUnknownMessageType] if the message has no registered type name.
// Returns [ErrSerializeFailed] wrapping the proto error on marshal failure.
func (x *ProtoSerializer) Serialize(message any) ([]byte, error) {
	msg, ok := message.(proto.Message)
	if !ok {
		return nil, ErrNotProtoMessage
	}

	messageName := proto.MessageName(msg)
	nameLen := len(messageName)
	if nameLen == 0 {
		return nil, ErrUnknownMessageType
	}

	protoSize := proto.Size(msg)
	totalLen := 4 + 4 + nameLen + protoSize

	// Single allocation: exact-size output frame.
	out := make([]byte, 0, totalLen)

	// Write both uint32 header fields into a stack-allocated array, then
	// append — no reflection, no interface boxing.
	var hdr [8]byte
	binary.BigEndian.PutUint32(hdr[0:4], uint32(totalLen))
	binary.BigEndian.PutUint32(hdr[4:8], uint32(nameLen))
	out = append(out, hdr[:]...)

	// Append the fully-qualified type name.
	out = append(out, messageName...)

	// Marshal the proto payload directly into the tail of out.
	out, err := proto.MarshalOptions{}.MarshalAppend(out, msg)
	if err != nil {
		return nil, errors.Join(ErrSerializeFailed, err)
	}

	return out, nil
}

// Deserialize implements [Serializer]. It decodes a frame produced by
// [Serialize], extracts the fully-qualified type name, resolves the concrete
// [proto.Message] type from [protoregistry.GlobalTypes], and unmarshals the
// proto payload into a fresh instance of that type. The returned value is the
// decoded [proto.Message] wrapped as any; callers can recover the original
// concrete type with a type assertion.
//
// The type-name extraction uses an unsafe []byte→string conversion to avoid
// a heap allocation; the resulting string is used only for the registry lookup.
//
// Returns [ErrInvalidFrame] for truncated or malformed frames.
// Returns [ErrUnknownMessageType] if the type name is not in the global registry.
// Returns [ErrDeserializeFailed] wrapping the proto error on unmarshal failure.
func (x *ProtoSerializer) Deserialize(data []byte) (any, error) {
	if len(data) < 8 {
		return nil, ErrInvalidFrame
	}

	totalLen := int(binary.BigEndian.Uint32(data[:4]))
	if len(data) < totalLen || totalLen < 8 {
		return nil, ErrInvalidFrame
	}

	nameLen := int(binary.BigEndian.Uint32(data[4:8]))
	if 8+nameLen > totalLen {
		return nil, ErrInvalidFrame
	}

	// Zero-copy string from the frame bytes. Safe because the string is only
	// used for the registry map lookup; protoregistry retains its own copy of
	// the key and does not hold a reference to our slice after the call.
	typeName := protoreflect.FullName(unsafe.String(unsafe.SliceData(data[8:8+nameLen]), nameLen))

	msgType, err := protoregistry.GlobalTypes.FindMessageByName(typeName)
	if err != nil {
		return nil, errors.Join(ErrUnknownMessageType, err)
	}

	msg := msgType.New().Interface()
	if err := proto.Unmarshal(data[8+nameLen:totalLen], msg); err != nil {
		return nil, errors.Join(ErrDeserializeFailed, err)
	}

	return msg, nil
}
