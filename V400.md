# v4.0.0 — Change Tracking

This document tracks the major and breaking changes in the v4.0.0 refactoring branch. It serves as an **architecture and changelog** reference: it describes exactly what V4 changes in terms of **simplification** (unified APIs, `any` instead of `proto.Message`, pluggable serializers including CBOR for any Go type) and **performance** (low-GC serialization, lock-free type registry, single-allocation frames, unified scheduler and PID handling).

---

## Breaking Changes

### 1. `proto.Message` replaced by `any` across the public API

All public methods that previously required `google.golang.org/protobuf/proto.Message` now accept `any`. This affects every message-passing surface in the system:

| Surface                                                      | Old signature                   | New signature         |
|--------------------------------------------------------------|---------------------------------|-----------------------|
| `PID.Tell`                                                   | `message proto.Message`         | `message any`         |
| `PID.Ask`                                                    | `message proto.Message`         | `message any`         |
| `PID.PipeTo` / `PipeToName` task                             | `func() (proto.Message, error)` | `func() (any, error)` |
| `ActorSystem.Schedule` / `ScheduleOnce` / `ScheduleWithCron` | `message proto.Message`         | `message any`         |
| `ActorSystem.AskGrain`                                       | `message proto.Message`         | `message any`         |
| `ActorSystem.TellGrain`                                      | `message proto.Message`         | `message any`         |
| `ActorSystem.handleRemoteAsk`                                | `message proto.Message`         | `message any`         |
| `ActorSystem.handleRemoteTell`                               | `message proto.Message`         | `message any`         |

**Migration:** Replace `proto.Message` type constraints in actor `Receive` handlers and call sites with plain `any`. Serialization is now handled by the new `remote.Serializer` layer (see below).

---

### 2. `goaktpb` package removed

The top-level `goaktpb` package (`goaktpb/goakt.pb.go`, `protos/goakt/goakt.proto`) has been deleted. All system-defined message types that lived in it are now plain Go structs in the `actor` package.

**Migration:** Remove any imports of `github.com/tochemey/goakt/v3/goaktpb`. Use the equivalent types from `github.com/tochemey/goakt/v4/actor` instead.

| Old (`goaktpb`)             | New (`actor`)             |
|-----------------------------|---------------------------|
| `goaktpb.PostStart`         | `actor.PostStart`         |
| `goaktpb.PoisonPill`        | `actor.PoisonPill`        |
| `goaktpb.Terminated`        | `actor.Terminated`        |
| `goaktpb.Deadletter`        | `actor.Deadletter`        |
| `goaktpb.NoMessage`         | `actor.NoMessage`         |
| `goaktpb.ActorStarted`      | `actor.ActorStarted`      |
| `goaktpb.ActorStopped`      | `actor.ActorStopped`      |
| `goaktpb.ActorPassivated`   | `actor.ActorPassivated`   |
| `goaktpb.ActorChildCreated` | `actor.ActorChildCreated` |
| `goaktpb.ActorRestarted`    | `actor.ActorRestarted`    |
| `goaktpb.ActorSuspended`    | `actor.ActorSuspended`    |
| `goaktpb.ActorReinstated`   | `actor.ActorReinstated`   |
| `goaktpb.NodeJoined`        | `actor.NodeJoined`        |
| `goaktpb.NodeLeft`          | `actor.NodeLeft`          |

Constructor functions (e.g. `actor.NewDeadletter(...)`, `actor.NewActorStarted(...)`) replace direct protobuf struct literals. Timestamps are now `time.Time` rather than `*timestamppb.Timestamp`.

---

### 3. Internal protobuf files removed

Two internal protobuf definitions that were used only for event delivery have been deleted:

- `protos/internal/deadletter.proto` / `internal/internalpb/deadletter.pb.go`
- `protos/internal/healthcheck.proto` / `internal/internalpb/healthcheck.pb.go`

Their payloads are now native Go structs (see above).

---

### 4. `supervisionSignal` decoupled from protobuf

`supervisionSignal.msg` changed from `proto.Message` to `any`, and `supervisionSignal.timestamp` changed from `*timestamppb.Timestamp` to `time.Time` (UTC). The `Msg()` and `Timestamp()` accessor return types follow accordingly. This is an internal type, but any code that reached into supervision internals must be updated.

---

### 5. Cluster event payload type changed

`internal/cluster.Event.Payload` changed from `*anypb.Any` to `any`. Two concrete typed event structs have been introduced to replace protobuf-wrapped cluster events:

```go
// internal/cluster
type NodeJoinedEvent struct {
    Address   string
    Timestamp time.Time
}

type NodeLeftEvent struct {
    Address   string
    Timestamp time.Time
}
```

---

## New Additions

### 6. `actor/messages.go` — native Go system messages

All system message types are now defined as plain Go structs with accessor methods and constructor functions. The full set includes:

- Lifecycle: `PostStart`, `PoisonPill`, `Terminated`, `NoMessage`, `PanicSignal`
- Actor events: `ActorStarted`, `ActorStopped`, `ActorPassivated`, `ActorChildCreated`, `ActorRestarted`, `ActorSuspended`, `ActorReinstated`
- Deadletter: `Deadletter`
- Cluster events: `NodeJoined`, `NodeLeft`

Each type carries a `time.Time` timestamp set at construction (UTC).

---

### 7. `actor/messages_serializers.go` — serialization support for native types

Provides `encoding`/serialization support for the native message types defined in `actor/messages.go`, so they can cross process boundaries over the remoting layer without requiring protobuf.

---

### 8. `remote/serializer.go` — pluggable serializer interface

A new `Serializer` interface decouples the remoting wire format from protobuf:

```go
type Serializer interface {
    Serialize(message any) ([]byte, error)
    Deserialize(data []byte) (any, error)
}
```

Implementations must be **self-describing**: the serialized bytes must embed enough type information (e.g. type name or ID) so that `Deserialize` can reconstruct the original concrete type on the receiving node without out-of-band coordination. The remoting layer guarantees non-nil message and non-empty data at the boundary; implementations should still validate and return descriptive errors.

---

### 9. `remote/proto_serializer.go` — built-in protobuf implementation

The default `Serializer` for values implementing `proto.Message`. Uses a length-prefixed, self-describing frame (totalLen, nameLen, fully-qualified type name, proto bytes). Registered by default in `NewClient` for the `proto.Message` interface so all protobuf messages use it unless overridden. Stateless and safe for concurrent use; encode path uses a single allocation and a stack-allocated 8-byte header.

---

### 10. `remote/serializer_dispatch.go` — type-based serializer dispatch

- **Send path:** The client resolves the serializer by message type: first an exact concrete-type match, then the first registered interface the message implements. The chosen serializer encodes the message. No lock on the hot path; the serializers slice is immutable after construction.
- **Receive path:** A composite `Serializer` (built once per client) tries each registered serializer in registration order and returns the first successful `Deserialize`. This allows protobuf and other formats (e.g. CBOR) to coexist; the first serializer that can decode the frame wins.

---

### 11. `remote/cbor_serializer.go` — CBOR serializer for any Go type

A `Serializer` implementation that encodes and decodes **arbitrary Go values** using [CBOR](https://cbor.io/) in the same length-prefixed frame layout as `ProtoSerializer` (totalLen, nameLen, type name, payload). Type names are the lowercased `reflect.Type` string used by the package-level types registry (`internal/types.Registry`).

- **Type registry:** All `CBORSerializer` instances share a single global registry. Types must be registered before use via `remote.RegisterSerializableTypes(new(MyMessage), ...)`. When using `WithSerializers(new(MyMessage), remote.NewCBORSerializer())` or `WithClientSerializers(..., remote.NewCBORSerializer())`, the same type must be registered for the **receive** path (deserialize resolves the concrete type by name from the registry). Register receive-only types explicitly with `RegisterSerializableTypes`.
- **Performance:** Single allocation for the frame on encode; stack-allocated 8-byte header; registry lookups use `internal/types.Registry` backed by `xsync.Map` (lock-free reads). Two allocations per serialize (frame + CBOR library output), one per deserialize (target value).
- **Options:** `WithSerializers` / `WithClientSerializers` bind a serializer to a concrete type or interface; the default remains `ProtoSerializer` for `proto.Message`.

---

### 12. `internal/commands` package

A new `internal/commands` package provides the internal command abstraction previously implemented inline in `pid.go` and `actor_system.go`. Extracted to reduce coupling and improve testability of the actor lifecycle machinery.

---

## Breaking Changes (continued)

### 14. `PID` is the sole actor reference — `ActorRef` removed

The `ActorRef` struct (defined in `actor/actor_ref.go`) has been deleted. `*PID` is now the single, unified handle for both **local** and **remote** actors.

- A local PID has a live mailbox, supervision state, and a full actor-system reference.
- A remote PID is a lightweight value that carries only the actor's `*address.Address` and a `remote.Client` handle; all messaging is dispatched through the remoting layer.
- Use `pid.IsLocal()` / `pid.IsRemote()` to distinguish the two when location matters.

**Migration:** Replace every `ActorRef` type annotation with `*PID`. Methods that returned `ActorRef` slices now return `[]*PID`.

---

### 15. `ActorSystem.ActorOf` — unified single-return signature

`ActorOf` previously returned three values `(addr *address.Address, pid *PID, err error)`. It now returns `(*PID, error)`.

| Case                   | Old return         | New return                                  |
|------------------------|--------------------|---------------------------------------------|
| Actor found locally    | `(addr, pid, nil)` | `(pid, nil)` — live local PID               |
| Actor found in cluster | `(addr, nil, nil)` | `(remotePID, nil)` — lightweight remote PID |
| Not found              | `(nil, nil, err)`  | `(nil, err)`                                |

**Migration:** Update all call sites. Use `pid.Address()` to obtain the `*address.Address` and `pid.IsLocal()` / `pid.IsRemote()` to test location.

---

### 16. `ActorSystem.Actors` — merged with `ActorRefs`, returns `([]*PID, error)`

`Actors() []*PID` (local-only, no error) and `ActorRefs(ctx, timeout) ([]ActorRef, error)` (cluster-aware) have been merged into a single method:

```go
Actors(ctx context.Context, timeout time.Duration) ([]*PID, error)
```

Local actors are returned as live PIDs; cluster actors on peer nodes are returned as remote PIDs. The `timeout` parameter bounds the cluster scan and is ignored when not in cluster mode.

**Migration:** Replace calls to `Actors()` with `Actors(ctx, timeout)` and calls to `ActorRefs(...)` with `Actors(ctx, timeout)`.

---

### 17. `ActorSystem.LocalActor` removed

`LocalActor(actorName string) (*PID, error)` has been deleted. Use `ActorOf` instead — it performs a fast local-tree lookup first and only falls through to the cluster when the actor is not found locally.

**Migration:** Replace `sys.LocalActor(name)` with `sys.ActorOf(ctx, name)`.

---

### 18. `ActorSystem.RemoteActor` removed

`RemoteActor(ctx, actorName) (*address.Address, error)` has been deleted. `ActorOf` already covers the cluster lookup path and returns a remote PID.

**Migration:** Replace `sys.RemoteActor(ctx, name)` with `sys.ActorOf(ctx, name)` and use `pid.Address()` if the raw address is needed.

---

### 19. Remote-specific scheduler methods removed

The three `Remote*` variants of the scheduler API have been removed from `ActorSystem`:

- `RemoteScheduleOnce(ctx, message, receiver *address.Address, delay, opts…)`
- `RemoteSchedule(ctx, message, receiver *address.Address, interval, opts…)`
- `RemoteScheduleWithCron(ctx, message, receiver *address.Address, cron, opts…)`

**Migration:** Obtain a remote PID via `ActorOf` (or construct one internally) and pass it to the unified `ScheduleOnce`, `Schedule`, or `ScheduleWithCron` methods. The scheduler now routes through the remoting layer automatically when the target PID is remote.

---

### 20. `ActorSystem.GetPartition` renamed to `Partition`

The method has been renamed for consistency with Go naming conventions.

**Migration:** Replace `sys.GetPartition(name)` with `sys.Partition(name)`.

---

### 21. `remote.Remoting` interface renamed to `remote.Client`

The primary remoting interface has been renamed from `Remoting` to `Client`. The implementation file `remote/remoting.go` has been renamed to `remote/client.go`. The generated mock `mocks/remote/remoting.go` has been deleted; use `mocks/remote/client.go` (`mockremote.NewClient(t)`) instead.

**Migration:**
- Replace `remote.Remoting` → `remote.Client`
- Replace `remote.NewRemoting()` → `remote.NewClient()`
- Replace `mockremote.NewRemoting(t)` → `mockremote.NewClient(t)`

---

### 22. `client.Node.Remoting()` removed

The `Remoting()` accessor on `client.Node` no longer exists. Remoting implementation details are not part of the public API.

---

### 23. `testkit.Probe.SenderAddress()` removed

`SenderAddress() *address.Address` has been removed from the `Probe` interface and its implementation. Because `PID` is now the unified actor reference and carries the address for both local and remote actors, callers can inspect the sender via `Sender()` and then call `pid.IsRemote()` / `pid.Address()` as needed.

---

### 23a. `ReceiveContext.SenderAddress()` and `ReceiveContext.ReceiverAddress()` removed

`SenderAddress() *address.Address` and `ReceiverAddress() *address.Address` have been removed from `ReceiveContext`. The unified `*PID` type carries the address for both local and remote actors.

**Migration:** Use `ctx.Sender().Address()` when the sender is non-nil (and `address.NoSender()` when nil), and `ctx.Self().Address()` for the receiver (and `address.NoSender()` when `Self()` is nil). This aligns with the removal of `Probe.SenderAddress()` and keeps a single way to obtain addresses via `PID`.

---

### 24. `PID.Kind()` — actor kind accessor

A new public method returns the reflected type name of the actor backing the PID:

```go
func (pid *PID) Kind() string
```

Returns an empty string for remote PIDs (which carry no actor instance).

---

### 25. Remote PID — lightweight cross-node actor handle

`newRemotePID(addr *address.Address, remoting remote.Client) *PID` is a new internal constructor that creates a minimal PID representing an actor on a remote node. It carries only the actor address and a remoting handle; all messaging is forwarded through the remoting layer. Remote PIDs are returned by `ActorOf` when an actor is found in the cluster but not locally.

---

### 26. `errors.ErrRemotingDisabled` and `errors.ErrNotLocal`

Two new sentinel errors have been added to the `errors` package:

- `ErrRemotingDisabled` — returned when a remote operation is attempted but remoting is not configured.
- `ErrNotLocal` — returned when an operation requires a local PID but a remote PID is provided.

---

## Bug Fixes

### 27. `cleanupCluster` singleton kind removal

**Problem:** During node shutdown, `cleanupCluster` was checking `pid.IsSingleton()` to decide whether to call `cluster.RemoveKind`. However, `pid.reset()` — which is called as part of actor shutdown — clears `singletonState` to `false`. By the time `cleanupCluster` ran, all actors had already been stopped, so `IsSingleton()` always returned `false` and `RemoveKind` was never called. The stale kind entry in the cluster store then prevented the new leader from spawning the relocated singleton (`ErrKindAlreadyExists` / `ErrSingletonAlreadyExists`).

**Fix:** `cleanupCluster` now checks `pid.singletonSpec != nil` instead of `pid.IsSingleton()`. `singletonSpec` is set at spawn time and is never cleared by `reset()`, so it correctly identifies singleton PIDs regardless of their running state.

---

## Internal Improvements

### 28. `address.Address.String()` — eager caching

`cachedStr` is now computed once inside the `New` and `NewWithParent` constructors rather than lazily on the first `String()` call. This makes `String()` a pure, safe concurrent read with zero branching and eliminates the one-time write-race window that existed under the lazy approach.

---

### 29. `internal/xsync.List` — deduplication and low-GC redesign

The generic list type gained several improvements:

- Type parameter tightened from `any` to `comparable`, enabling built-in deduplication.
- `Append` and `AppendMany` are now no-ops for items already present.
- New `Contains(item T) bool` method.
- Pre-allocated backing array (`cap=4`) to avoid the first resize on small lists.
- Cleared slots are zeroed immediately on `Reset` to prevent pointer/interface values from blocking GC.
- `Get` accesses the element while holding the read lock, preventing a concurrent reallocation from invalidating a bounds check that was performed before the lock.

---

### 30. Scheduler — unified local/remote delivery

`makeJobFn` in `actor/scheduler.go` was refactored to remove the separate remote-PID check. `PID.Tell` already handles the local/remote routing decision internally, so the scheduler passes the target PID directly to `Tell` without any `IsRemote` branching, keeping the hot path allocation-free.

The `scheduler` struct now holds an explicit `actorSystem` reference (passed at construction) so that `NoSender()` can be obtained without calling `pid.ActorSystem()` — which returns `nil` for remote PIDs and would have panicked.

---

### 31. `toReceiveContext` — else-branch elimination

`toReceiveContext` in `actor/api.go` was refactored to remove redundant `else` branches. Remote-message deserialization now mutates `from` and `message` in place before a single unconditional `receiveContext.build` call at the end of the function.

---

## V4 in brief — simplification and performance

- **Simplification:** One actor reference (`*PID`), one lookup API (`ActorOf`), one scheduler and one serializer abstraction. Messages are `any`; serialization is pluggable (ProtoSerializer by default, CBORSerializer for any Go type). No more `ActorRef` vs PID, no `LocalActor`/`RemoteActor`/`RemoteSchedule*` variants.
- **Performance:** Remoting uses a single-allocation frame and lock-free type resolution where applicable. Proto and CBOR serializers avoid extra buffers and use a shared types registry with lock-free reads. Scheduler and receive path avoid redundant branches and allocations.
