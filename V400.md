# GoAkt v4.0.0 — Change Tracking

This document tracks the major and breaking changes in the v4.0.0 refactoring branch. It serves as an **architecture and migration reference** for engineers refactoring applications to v4.

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Migration Quick Reference](#migration-quick-reference)
3. [Breaking Changes](#breaking-changes)
4. [New Additions](#new-additions)
5. [Bug Fixes](#bug-fixes)
6. [Internal Improvements](#internal-improvements)
7. [Remoting Capabilities](#remoting-capabilities)
8. [Summary: Simplification & Performance](#summary-simplification--performance)

---

## Executive Summary

v4.0.0 delivers **simplification** and **performance** through:

| Theme                | Key Changes                                                                                              |
| -------------------- | -------------------------------------------------------------------------------------------------------- |
| **Unified APIs**     | Single actor reference (`*PID`), single lookup (`ActorOf`), unified scheduler, pluggable serializers     |
| **Type Flexibility** | `any` replaces `proto.Message` across all message-passing surfaces; CBOR supports arbitrary Go types     |
| **Remoting**         | Config-only public API; client is internal; ProtoSerializer (default) and CBORSerializer for any Go type |
| **Identity**         | `Path` interface replaces `*address.Address`; `address` package moved to `internal/address`              |
| **Performance**      | Low-GC serialization, lock-free type registry, single-allocation frames, lock-free `PID.Path()`          |

---

## Migration Quick Reference

| From                                            | To                                                                                                  |
| ----------------------------------------------- | --------------------------------------------------------------------------------------------------- |
| `proto.Message` in handlers/call sites          | `any`                                                                                               |
| `goaktpb.*` types                               | `actor.*` (e.g. `actor.PostStart`, `actor.PoisonPill`)                                              |
| `ActorRef`                                      | `*PID`                                                                                              |
| `ActorOf` → `(addr, pid, err)`                  | `ActorOf` → `(*PID, error)`                                                                         |
| `Actors()` / `ActorRefs(ctx, timeout)`          | `Actors(ctx, timeout) ([]*PID, error)`                                                              |
| `LocalActor(name)`                              | `ActorOf(ctx, name)`                                                                                |
| `RemoteActor(ctx, name)`                        | `ActorOf(ctx, name)`                                                                                |
| `RemoteSchedule*` methods                       | `Schedule*` with remote PID from `ActorOf`                                                          |
| `GetPartition(name)`                            | `Partition(name)`                                                                                   |
| `pid.Address()`                                 | `pid.Path()`                                                                                        |
| `ctx.SenderAddress()` / `ctx.ReceiverAddress()` | `ctx.Sender().Path()` / `ctx.Self().Path()`                                                         |
| `remote.Remoting` / `remote.Client`             | Use actor system and `client.Node` APIs; configure via `WithRemoteConfig`                           |
| `WithRemoting`                                  | `WithRemoteConfig(config)`                                                                          |
| `address` package                               | `internal/address` (use `Path` interface instead)                                                   |
| Custom `Logger` implementations                 | Implement new methods: `*Context`, `LogLevel`, `Enabled`, `With`, `LogOutput`, `Flush`, `StdLogger` |

---

## Breaking Changes

### API & Type System

#### 1. `proto.Message` replaced by `any`

All public methods that previously required `google.golang.org/protobuf/proto.Message` now accept `any`:

| Surface                                                      | Old                             | New                   |
| ------------------------------------------------------------ | ------------------------------- | --------------------- |
| `PID.Tell`                                                   | `message proto.Message`         | `message any`         |
| `PID.Ask`                                                    | `message proto.Message`         | `message any`         |
| `PID.PipeTo` / `PipeToName`                                  | `func() (proto.Message, error)` | `func() (any, error)` |
| `ActorSystem.Schedule` / `ScheduleOnce` / `ScheduleWithCron` | `message proto.Message`         | `message any`         |
| `ActorSystem.AskGrain` / `TellGrain`                         | `message proto.Message`         | `message any`         |
| `handleRemoteAsk` / `handleRemoteTell`                       | `message proto.Message`         | `message any`         |

**Migration:** Replace `proto.Message` in actor `Receive` handlers and call sites with `any`. Serialization is handled by the `remote.Serializer` layer.

---

#### 2. `goaktpb` package removed

The top-level `goaktpb` package has been deleted. System message types are now plain Go structs in `actor`:

| Old (`goaktpb`)             | New (`actor`)             |
| --------------------------- | ------------------------- |
| `goaktpb.PostStart`         | `actor.PostStart`         |
| `goaktpb.PoisonPill`        | `actor.PoisonPill`        |
| `goaktpb.Terminated`        | `actor.Terminated`        |
| `goaktpb.Deadletter`        | `actor.Deadletter`        |
| `goaktpb.NoMessage`         | `actor.NoMessage`         |
| `goaktpb.ActorStarted`      | `actor.ActorStarted`      |
| `goaktpb.ActorStopped`      | `actor.ActorStopped`      |
| `goaktpb.ActorPassivated`   | `actor.ActorPassivated`   |
| `goaktpb.ActorChildCreated` | `actor.ActorChildCreated` |
| `goaktpb.ActorRestarted`    | `actor.ActorRestarted`    |
| `goaktpb.ActorSuspended`    | `actor.ActorSuspended`    |
| `goaktpb.ActorReinstated`   | `actor.ActorReinstated`   |
| `goaktpb.NodeJoined`        | `actor.NodeJoined`        |
| `goaktpb.NodeLeft`          | `actor.NodeLeft`          |

Constructor functions (e.g. `actor.NewDeadletter(...)`) replace protobuf struct literals. Timestamps are `time.Time` instead of `*timestamppb.Timestamp`.

---

#### 3. Internal protobuf files removed

- `protos/internal/deadletter.proto` / `internal/internalpb/deadletter.pb.go`
- `protos/internal/healthcheck.proto` / `internal/internalpb/healthcheck.pb.go`

Payloads are now native Go structs.

---

#### 4. `supervisionSignal` decoupled from protobuf

- `supervisionSignal.msg`: `proto.Message` → `any`
- `supervisionSignal.timestamp`: `*timestamppb.Timestamp` → `time.Time` (UTC)

---

#### 5. Cluster event payload type changed

`internal/cluster.Event.Payload` changed from `*anypb.Any` to `any`. Typed event structs:

```go
// internal/cluster
type NodeJoinedEvent struct {
    Address   string
    Timestamp time.Time
}

type NodeLeftEvent struct {
    Address   string
    Timestamp time.Time
}
```

---

### Actor Reference & Lookup

#### 6. `PID` is the sole actor reference — `ActorRef` removed

`ActorRef` has been deleted. `*PID` is the unified handle for local and remote actors:

- **Local PID:** Live mailbox, supervision state, full actor-system reference
- **Remote PID:** Lightweight value with `*address.Address` and remoting handle; messaging via remoting layer

Use `pid.IsLocal()` / `pid.IsRemote()` when location matters.

**Migration:** Replace `ActorRef` with `*PID`; methods returning `ActorRef` slices now return `[]*PID`.

---

#### 7. `ActorSystem.ActorOf` — unified return signature

| Case                   | Old                | New                       |
| ---------------------- | ------------------ | ------------------------- |
| Actor found locally    | `(addr, pid, nil)` | `(pid, nil)` — local PID  |
| Actor found in cluster | `(addr, nil, nil)` | `(pid, nil)` — remote PID |
| Not found              | `(nil, nil, err)`  | `(nil, err)`              |

**Migration:** Use `pid.Path()` for host/port/name/system; `pid.IsLocal()` / `pid.IsRemote()` for location.

---

#### 8. `ActorSystem.Actors` — merged with `ActorRefs`

```go
// Before
Actors() []*PID
ActorRefs(ctx, timeout) ([]ActorRef, error)

// After
Actors(ctx context.Context, timeout time.Duration) ([]*PID, error)
```

Local actors are live PIDs; cluster actors are remote PIDs. `timeout` bounds cluster scan and is ignored when not in cluster mode.

---

#### 9. `LocalActor` and `RemoteActor` removed

| Removed                                                 | Replacement                               |
| ------------------------------------------------------- | ----------------------------------------- |
| `LocalActor(actorName string) (*PID, error)`            | `ActorOf(ctx, name)`                      |
| `RemoteActor(ctx, actorName) (*address.Address, error)` | `ActorOf(ctx, name)` — returns remote PID |

---

#### 10. Remote-specific scheduler methods removed

- `RemoteScheduleOnce`, `RemoteSchedule`, `RemoteScheduleWithCron` removed

**Migration:** Obtain remote PID via `ActorOf` and use unified `ScheduleOnce`, `Schedule`, or `ScheduleWithCron`.

---

#### 11. `GetPartition` renamed to `Partition`

**Migration:** `sys.GetPartition(name)` → `sys.Partition(name)`.

---

### Remoting & Configuration

#### 12. Remoting client no longer exported

The remoting client is internal. The `remote` package exposes only configuration and protocol types (`Config`, `Serializer`, `Compression`, `ContextPropagator`, `SpawnRequest`, etc.).

**Migration:**

- Replace `remote.Remoting` / `remote.Client` — use actor system and `client.Node` APIs
- Replace `remote.NewRemoting()` / `remote.NewClient()` — use `WithRemoteConfig(config)`
- For tests: `mockremote.NewClient(t)` for mock injection

---

#### 13. `client.Node.Remoting()` and `WithRemoting` removed

Remoting is configured exclusively via `WithRemoteConfig(config *remote.Config)`. The node constructs its remoting client from the config.

---

### Log Package

#### 14. `Logger` interface extended — custom implementations must add new methods

The `Logger` interface now includes context-aware methods (`InfoContext`, `InfofContext`, `WarnContext`, `WarnfContext`, `ErrorContext`, `ErrorfContext`, `DebugContext`, `DebugfContext`), plus `LogLevel()`, `Enabled()`, `With()`, `LogOutput()`, `Flush()`, and `StdLogger()`. See §30 for the full API table.

**Migration:** Custom `Logger` implementations must implement all new methods. Use `log.DiscardLogger` for tests.

---

### Testkit & ReceiveContext

#### 15. `testkit.Probe.SenderAddress()` removed

**Migration:** Use `Sender()` and then `pid.IsRemote()` / `pid.Path()` as needed.

---

#### 16. `ReceiveContext.SenderAddress()` and `ReceiverAddress()` removed

**Migration:** Use `ctx.Sender().Path()` (when sender non-nil) and `ctx.Self().Path()` for receiver.

---

### Address & Path

#### 17. `address` package moved to `internal/address`

**Migration:** Remove imports of `github.com/tochemey/goakt/v4/address`. Use the `Path` interface from `pid.Path()` instead.

---

#### 18. `PID.Address()` replaced by `PID.Path()`

```go
func (pid *PID) Path() Path
```

| Old                           | New                            |
| ----------------------------- | ------------------------------ |
| `pid.Address().String()`      | `pid.Path().String()`          |
| `pid.Address().Name()`        | `pid.Path().Name()`            |
| `pid.Address().Host()`        | `pid.Path().Host()`            |
| `pid.Address().Port()`        | `pid.Path().Port()`            |
| `pid.Address().HostPort()`    | `pid.Path().HostPort()`        |
| `pid.Address().System()`      | `pid.Path().System()`          |
| `pid.Address().Equals(other)` | `pid.Path().Equals(otherPath)` |

`Path()` returns `nil` for nil PID. Guard accordingly (e.g. for `NoSender`).

---

## New Additions

### System Messages & Serialization

#### 19. `actor/messages.go` — native Go system messages

System message types are plain Go structs with constructors and accessors:

- **Lifecycle:** `PostStart`, `PoisonPill`, `Terminated`, `NoMessage`, `PanicSignal`
- **Actor events:** `ActorStarted`, `ActorStopped`, `ActorPassivated`, `ActorChildCreated`, `ActorRestarted`, `ActorSuspended`, `ActorReinstated`
- **Deadletter:** `Deadletter`
- **Cluster events:** `NodeJoined`, `NodeLeft`

Each type carries a `time.Time` timestamp (UTC) set at construction.

---

#### 20. `actor/messages_serializers.go` — serialization for native types

Provides encoding support for native message types so they can cross process boundaries without protobuf.

---

#### 21. `remote/serializer.go` — pluggable serializer interface

```go
type Serializer interface {
    Serialize(message any) ([]byte, error)
    Deserialize(data []byte) (any, error)
}
```

Implementations must be **self-describing**: serialized bytes must embed type information so `Deserialize` can reconstruct the concrete type on the receiving node.

---

#### 22. `remote/proto_serializer.go` — built-in protobuf implementation

Default `Serializer` for `proto.Message`. Uses length-prefixed, self-describing frames (totalLen, nameLen, fully-qualified type name, proto bytes). Stateless, safe for concurrent use; single allocation on encode.

---

#### 23. Serializer dispatch — server and client

- **Server (inbound):** `remote.Config.Serializer(msg)` resolves by `map[reflect.Type]Serializer` — exact type first, then first matching interface
- **Client (outbound):** Same dispatch order; serializers immutable after construction; no lock on hot path
- **Receive path:** Composite `Serializer` tries each registered serializer in order; first successful `Deserialize` wins (protobuf and CBOR can coexist)

---

#### 24. `remote/cbor_serializer.go` — CBOR for any Go type

Encodes/decodes arbitrary Go values using [CBOR](https://cbor.io/) in the same length-prefixed frame layout as `ProtoSerializer`.

- **Type registry:** Register types via `remote.RegisterSerializableTypes(new(MyMessage), ...)` before use
- **Performance:** Single allocation on encode; lock-free registry (`xsync.Map`); two allocations per serialize, one per deserialize
- **Options:** `WithSerializers` / `WithClientSerializers` bind serializer to type/interface; default remains `ProtoSerializer` for `proto.Message`

---

### Path & Identity

#### 25. `Path` interface — location-transparent actor identity

```go
type Path interface {
    Host()     string
    HostPort() string
    Port()     int
    Name()     string
    Parent()   Path
    String()   string
    System()   string
    Equals(other Path) bool
}
```

Returned by `PID.Path()`. `String()` and `HostPort()` are pre-computed and cached; `Equals` is a single cached-string comparison.

---

### Remote Capabilities

#### 26. `remote/actor_state.go` — `ActorState` and `RemoteState`

`ActorState` enum for querying actor lifecycle/configuration on remote nodes:

| Value                   | Description                              |
| ----------------------- | ---------------------------------------- |
| `ActorStateUnknown`     | Unspecified (typically returns false)    |
| `ActorStateRunning`     | Actor is active (`pid.IsRunning()`)      |
| `ActorStateSuspended`   | Actor suspended (`pid.IsSuspended()`)    |
| `ActorStateStopping`    | Actor shutting down (`pid.IsStopping()`) |
| `ActorStateRelocatable` | Actor configured for relocation          |
| `ActorStateSingleton`   | Actor is a cluster singleton             |

```go
ok, err := client.RemoteState(ctx, host, port, "my-actor", remote.ActorStateRunning)
```

Values align with `internalpb.State` proto enum for wire compatibility.

---

### PID & Errors

#### 27. `PID.Kind()` — actor kind accessor

```go
func (pid *PID) Kind() string
```

Returns reflected type name of the actor backing the PID. Empty string for remote PIDs.

---

#### 28. Remote PID — lightweight cross-node handle

`newRemotePID` creates a minimal PID for actors on remote nodes. Carries address and remoting handle; all messaging via remoting layer. Returned by `ActorOf` when actor is found in cluster but not locally.

---

#### 29. New sentinel errors

- `errors.ErrRemotingDisabled` — remote operation attempted but remoting not configured
- `errors.ErrNotLocal` — operation requires local PID but remote PID provided

---

### Log Package

#### 30. `Logger` interface — extended with context, structured logging, and introspection

The `Logger` interface has been extended with new methods. Custom implementations must implement all of them:

| Method                                                                                                                         | Purpose                                                                                                              |
| ------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------- |
| `InfoContext`, `InfofContext`, `WarnContext`, `WarnfContext`, `ErrorContext`, `ErrorfContext`, `DebugContext`, `DebugfContext` | Context-aware logging for trace propagation                                                                          |
| `LogLevel() Level`                                                                                                             | Returns the configured minimum severity level                                                                        |
| `Enabled(level Level) bool`                                                                                                    | Check before expensive work: `if logger.Enabled(log.DebugLevel) { logger.Debugf("expensive: %v", expensiveFunc()) }` |
| `With(keyValues ...any) Logger`                                                                                                | Structured fields; keys and values alternate; keys must be strings                                                   |
| `LogOutput() []io.Writer`                                                                                                      | Returns configured output destinations                                                                               |
| `Flush() error`                                                                                                                | Drain buffered output (no-op for unbuffered)                                                                         |
| `StdLogger() *log.Logger`                                                                                                      | Compatibility with stdlib `*log.Logger` for third-party integrations                                                 |

**Migration:** Custom `Logger` implementations must add the new methods. Use `log.DiscardLogger` in tests if you need a no-op.

---

#### 31. `log/slog.go` — stdlib slog implementation with low-GC optimizations

`log.NewSlog(level, writers...)` provides a `Logger` backed by `log/slog`:

- **Enabled-before-format:** `Enabled()` is checked before formatting in all `Xf` methods to avoid allocations when disabled
- **Typed attrs:** `toSlogAttrs` uses typed `slog.Attr` for string, int, int32, int64, uint, uint32, uint64, bool, float64, time.Time to minimize reflection
- **Caller caching:** `callerCache` (sync.Map) caches caller `slog.Attr` by PC to avoid repeated `runtime.Caller` and string building
- **Buffer pooling:** `sync.Pool` for buffers and JSON encoders; buffers >16KB not returned to pool
- **Zero-alloc JSON escape:** `appendJSONEscaped` avoids allocation for strings that need no escaping
- **formatMsg:** Skips `fmt.Sprintf` when format has no verbs and no args
- **slogOrderedHandler:** Custom handler with zap-style field order: `level`, `ts`, `caller`, `msg`, then other attrs
- **StdLogger:** Returns `slog.NewLogLogger` for stdlib compatibility

---

#### 32. `log/zap.go` — Zap implementation with buffered file output

`log.NewZap(level, writers...)` provides a `Logger` backed by `go.uber.org/zap`:

- **Buffered file output:** Info/Warn/Debug to file writers use 256KB buffer with 30s flush interval; reduces syscalls
- **Unbuffered stdout/stderr:** Immediate visibility for interactive use
- **Error+ unbuffered:** Fatal, Panic, Error always write immediately
- **Typed fields:** `toZapField` uses zap.String/Int64/Bool etc. for common types to avoid `zap.Any` reflection
- **Stack-allocated With:** Up to `maxInlineFields` (6) pairs use stack array in `With()` to avoid heap allocation
- **Flush:** Call `Flush()` during graceful shutdown to drain buffered file output and sync file descriptors
- **StdLogger:** Returns `*log.Logger` via `zap.NewStdLogAt` for third-party integrations

**Global loggers:** `log.DebugLogger`, `log.DefaultLogger` (Zap), `log.DiscardLogger` (no-op).

---

#### 33. `log/discard.go` — no-op logger

`log.DiscardLogger` implements the full `Logger` interface with no-op behavior. `Enabled()` returns false for all levels except Fatal and Panic (which always execute). Use for tests or when logging is disabled.

---

### Internal Extractions

#### 34. `internal/commands` package

Command abstraction extracted from `pid.go` and `actor_system.go` to reduce coupling and improve testability of actor lifecycle machinery.

---

## Bug Fixes

#### 35. `cleanupCluster` singleton kind removal

**Problem:** During shutdown, `cleanupCluster` used `pid.IsSingleton()` to decide whether to call `cluster.RemoveKind`. `pid.reset()` clears `singletonState` to `false` during actor shutdown, so by the time `cleanupCluster` ran, `IsSingleton()` was always false and `RemoveKind` was never called. Stale kind entries caused `ErrKindAlreadyExists` / `ErrSingletonAlreadyExists` for the new leader.

**Fix:** `cleanupCluster` now checks `pid.singletonSpec != nil` instead of `pid.IsSingleton()`. `singletonSpec` is set at spawn and never cleared by `reset()`.

---

## Internal Improvements

#### 36. `address.Address.String()` — eager caching

`cachedStr` is computed once in `New` / `NewWithParent` constructors instead of lazily on first `String()` call. Eliminates write-race window and makes `String()` a pure concurrent read.

---

#### 37. `internal/xsync.List` — deduplication and low-GC redesign

- Type parameter: `any` → `comparable` (enables deduplication)
- `Append` / `AppendMany` no-op for items already present
- New `Contains(item T) bool`
- Pre-allocated backing array (cap=4)
- Cleared slots zeroed on `Reset` to avoid blocking GC
- `Get` accesses element while holding read lock to prevent reallocation races

---

#### 38. Scheduler — unified local/remote delivery

`makeJobFn` passes target PID directly to `PID.Tell`; no separate remote-PID branching. `Tell` handles routing internally. Scheduler holds explicit `actorSystem` reference for `NoSender()` (avoids `pid.ActorSystem()` returning nil for remote PIDs).

---

#### 39. `toReceiveContext` — else-branch elimination

Remote-message deserialization mutates `from` and `message` in place before a single unconditional `receiveContext.build` call.

---

#### 40. `actor/actor_path.go` — low-GC path implementation

- **`HostPort()` allocation-free:** Pre-computed and cached in `cachedHostPort` at construction
- **`Equals`:** Single `cachedStr == other.String()` comparison
- **`PID.Path()` lock-free:** `path` written once in constructors; never mutated; no lock on read

---

## Remoting Capabilities

The remoting layer enables cross-process actor communication via a **server** (inbound, `remote.Config`) and **client** (outbound, internal). Both share serializers, compression, and context propagation.

### Transport & Security

- **Protocol:** Length-prefixed TCP frames; pooled connections
- **TLS:** Optional
- **Compression:** `NoCompression`, `GzipCompression`, `ZstdCompression` (default), `BrotliCompression`

### Server Configuration (`remote.Config`)

| Option                                   | Purpose                                  |
| ---------------------------------------- | ---------------------------------------- |
| `NewConfig(bindAddr, bindPort, opts...)` | Create config                            |
| `WithWriteTimeout`                       | Connection close if no data written      |
| `WithReadIdleTimeout`                    | Health check / ping                      |
| `WithMaxFrameSize`                       | 16KB–16MB                                |
| `WithCompression`                        | Must match client                        |
| `WithContextPropagator`                  | Trace IDs, auth tokens across boundaries |
| `WithSerializers`                        | Per-type or per-interface serializers    |

### Messaging Operations

| Method                                             | Description              |
| -------------------------------------------------- | ------------------------ |
| `RemoteTell(ctx, from, to, message)`               | Fire-and-forget          |
| `RemoteAsk(ctx, from, to, message, timeout)`       | Request/response         |
| `RemoteBatchTell(ctx, from, to, messages)`         | Multiple fire-and-forget |
| `RemoteBatchAsk(ctx, from, to, messages, timeout)` | Multiple requests        |

### Actor Lifecycle Operations

| Method                                       | Description                                  |
| -------------------------------------------- | -------------------------------------------- |
| `RemoteLookup(ctx, host, port, name)`        | Resolve actor address                        |
| `RemoteSpawn(ctx, host, port, spawnRequest)` | Create actor on remote node                  |
| `RemoteReSpawn(ctx, host, port, name)`       | Restart actor                                |
| `RemoteStop(ctx, host, port, name)`          | Terminate actor                              |
| `RemoteReinstate(ctx, host, port, name)`     | Resume passivated actor                      |
| `RemoteState(ctx, host, port, name, state)`  | Query actor state (running, suspended, etc.) |

### Spawning Actors Remotely

```go
pid, err := system.Spawn(ctx, "my-actor", NewMyActor(),
    WithHostAndPort("192.168.1.10", 9000),
    WithRelocationDisabled(),
    WithDependencies(dep1, dep2),
)
```

| Option                              | Description                                    |
| ----------------------------------- | ---------------------------------------------- |
| `WithHostAndPort(host, port)`       | Target remote node (required for remote spawn) |
| `WithRelocationDisabled()`          | No relocation on host failure                  |
| `WithDependencies(...)`             | Injected on remote node                        |
| `WithStashing()`                    | Enable stashing                                |
| `WithPassivationStrategy(strategy)` | Passivation behavior                           |
| `WithReentrancy(reentrancy)`        | Async request policy                           |
| `WithSupervisor(supervisor)`        | Failure handling                               |
| `WithRole(role)`                    | Require remote node role                       |

### Grain Operations

| Method                                                            | Description               |
| ----------------------------------------------------------------- | ------------------------- |
| `RemoteActivateGrain(ctx, host, port, grainRequest)`              | Activate grain            |
| `RemoteTellGrain(ctx, host, port, grainRequest, message)`         | Fire-and-forget to grain  |
| `RemoteAskGrain(ctx, host, port, grainRequest, message, timeout)` | Request/response to grain |

### Serialization

- **Default:** `ProtoSerializer` for `proto.Message`
- **CBOR:** `remote.NewCBORSerializer()` for arbitrary Go types; register with `remote.RegisterSerializableTypes`
- **Custom:** Implement `remote.Serializer`; register via `WithSerializers` on `remote.Config`

---

## Summary: Simplification & Performance

### Simplification

- **One actor reference:** `*PID` for local and remote
- **One lookup API:** `ActorOf` replaces `LocalActor`, `RemoteActor`, `ActorRefs`
- **One scheduler:** No `RemoteSchedule*` variants
- **One serializer abstraction:** Pluggable; ProtoSerializer default, CBOR for any Go type
- **Messages as `any`:** No `proto.Message` constraint
- **Config-only remoting:** Client is internal; configure via `WithRemoteConfig`
- **Path interface:** Single way to obtain actor identity; `address` package internal

### Performance

- **Remoting:** Single-allocation frames; lock-free type resolution
- **Proto/CBOR:** Shared types registry with lock-free reads
- **Scheduler/receive path:** Fewer branches and allocations
- **`PID.Path()`:** Lock-free; `Path.HostPort()` and `Path.Equals()` zero-allocation after construction
