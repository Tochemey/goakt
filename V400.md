# v4.0.0 — Change Tracking

This document tracks the major and breaking changes in the v4.0.0 refactoring branch. It serves as an **architecture and changelog** reference: it describes exactly what V4 changes in terms of **simplification** (unified APIs, `any` instead of `proto.Message`, pluggable serializers including CBOR for any Go type) and **performance** (low-GC serialization, lock-free type registry, single-allocation frames, unified scheduler and PID handling).

---

## Breaking Changes

### 1. `proto.Message` replaced by `any` across the public API

All public methods that previously required `google.golang.org/protobuf/proto.Message` now accept `any`. This affects every message-passing surface in the system:

| Surface                                                      | Old signature                   | New signature         |
|--------------------------------------------------------------|---------------------------------|-----------------------|
| `PID.Tell`                                                   | `message proto.Message`         | `message any`         |
| `PID.Ask`                                                    | `message proto.Message`         | `message any`         |
| `PID.PipeTo` / `PipeToName` task                             | `func() (proto.Message, error)` | `func() (any, error)` |
| `ActorSystem.Schedule` / `ScheduleOnce` / `ScheduleWithCron` | `message proto.Message`         | `message any`         |
| `ActorSystem.AskGrain`                                       | `message proto.Message`         | `message any`         |
| `ActorSystem.TellGrain`                                      | `message proto.Message`         | `message any`         |
| `ActorSystem.handleRemoteAsk`                                | `message proto.Message`         | `message any`         |
| `ActorSystem.handleRemoteTell`                               | `message proto.Message`         | `message any`         |

**Migration:** Replace `proto.Message` type constraints in actor `Receive` handlers and call sites with plain `any`. Serialization is now handled by the new `remote.Serializer` layer (see below).

---

### 2. `goaktpb` package removed

The top-level `goaktpb` package (`goaktpb/goakt.pb.go`, `protos/goakt/goakt.proto`) has been deleted. All system-defined message types that lived in it are now plain Go structs in the `actor` package.

**Migration:** Remove any imports of `github.com/tochemey/goakt/v3/goaktpb`. Use the equivalent types from `github.com/tochemey/goakt/v4/actor` instead.

| Old (`goaktpb`)             | New (`actor`)             |
|-----------------------------|---------------------------|
| `goaktpb.PostStart`         | `actor.PostStart`         |
| `goaktpb.PoisonPill`        | `actor.PoisonPill`        |
| `goaktpb.Terminated`        | `actor.Terminated`        |
| `goaktpb.Deadletter`        | `actor.Deadletter`        |
| `goaktpb.NoMessage`         | `actor.NoMessage`         |
| `goaktpb.ActorStarted`      | `actor.ActorStarted`      |
| `goaktpb.ActorStopped`      | `actor.ActorStopped`      |
| `goaktpb.ActorPassivated`   | `actor.ActorPassivated`   |
| `goaktpb.ActorChildCreated` | `actor.ActorChildCreated` |
| `goaktpb.ActorRestarted`    | `actor.ActorRestarted`    |
| `goaktpb.ActorSuspended`    | `actor.ActorSuspended`    |
| `goaktpb.ActorReinstated`   | `actor.ActorReinstated`   |
| `goaktpb.NodeJoined`        | `actor.NodeJoined`        |
| `goaktpb.NodeLeft`          | `actor.NodeLeft`          |

Constructor functions (e.g. `actor.NewDeadletter(...)`, `actor.NewActorStarted(...)`) replace direct protobuf struct literals. Timestamps are now `time.Time` rather than `*timestamppb.Timestamp`.

---

### 3. Internal protobuf files removed

Two internal protobuf definitions that were used only for event delivery have been deleted:

- `protos/internal/deadletter.proto` / `internal/internalpb/deadletter.pb.go`
- `protos/internal/healthcheck.proto` / `internal/internalpb/healthcheck.pb.go`

Their payloads are now native Go structs (see above).

---

### 4. `supervisionSignal` decoupled from protobuf

`supervisionSignal.msg` changed from `proto.Message` to `any`, and `supervisionSignal.timestamp` changed from `*timestamppb.Timestamp` to `time.Time` (UTC). The `Msg()` and `Timestamp()` accessor return types follow accordingly. This is an internal type, but any code that reached into supervision internals must be updated.

---

### 5. Cluster event payload type changed

`internal/cluster.Event.Payload` changed from `*anypb.Any` to `any`. Two concrete typed event structs have been introduced to replace protobuf-wrapped cluster events:

```go
// internal/cluster
type NodeJoinedEvent struct {
    Address   string
    Timestamp time.Time
}

type NodeLeftEvent struct {
    Address   string
    Timestamp time.Time
}
```

---

## New Additions

### 6. `actor/messages.go` — native Go system messages

All system message types are now defined as plain Go structs with accessor methods and constructor functions. The full set includes:

- Lifecycle: `PostStart`, `PoisonPill`, `Terminated`, `NoMessage`, `PanicSignal`
- Actor events: `ActorStarted`, `ActorStopped`, `ActorPassivated`, `ActorChildCreated`, `ActorRestarted`, `ActorSuspended`, `ActorReinstated`
- Deadletter: `Deadletter`
- Cluster events: `NodeJoined`, `NodeLeft`

Each type carries a `time.Time` timestamp set at construction (UTC).

---

### 7. `actor/messages_serializers.go` — serialization support for native types

Provides `encoding`/serialization support for the native message types defined in `actor/messages.go`, so they can cross process boundaries over the remoting layer without requiring protobuf.

---

### 8. `remote/serializer.go` — pluggable serializer interface

A new `Serializer` interface decouples the remoting wire format from protobuf:

```go
type Serializer interface {
    Serialize(message any) ([]byte, error)
    Deserialize(data []byte) (any, error)
}
```

Implementations must be **self-describing**: the serialized bytes must embed enough type information (e.g. type name or ID) so that `Deserialize` can reconstruct the original concrete type on the receiving node without out-of-band coordination. The remoting layer guarantees non-nil message and non-empty data at the boundary; implementations should still validate and return descriptive errors.

---

### 9. `remote/proto_serializer.go` — built-in protobuf implementation

The default `Serializer` for values implementing `proto.Message`. Uses a length-prefixed, self-describing frame (totalLen, nameLen, fully-qualified type name, proto bytes). Registered by default in the remoting client and in `remote.NewConfig` / `remote.DefaultConfig` for the `proto.Message` interface so all protobuf messages use it unless overridden. Stateless and safe for concurrent use; encode path uses a single allocation and a stack-allocated 8-byte header.

---

### 10. Serializer dispatch — server and client

- **Server (inbound):** `remote.Config.Serializer(msg)` resolves the serializer from the config's `map[reflect.Type]Serializer` — exact concrete-type match first, then the first registered interface the message implements. Used for deserializing incoming messages.
- **Client (outbound):** The remoting client resolves the serializer by message type using the same dispatch order. The serializers slice is immutable after construction; no lock on the hot path.
- **Receive path:** A composite `Serializer` (built once per client) tries each registered serializer in registration order and returns the first successful `Deserialize`. This allows protobuf and other formats (e.g. CBOR) to coexist; the first serializer that can decode the frame wins.

---

### 11. `remote/cbor_serializer.go` — CBOR serializer for any Go type

A `Serializer` implementation that encodes and decodes **arbitrary Go values** using [CBOR](https://cbor.io/) in the same length-prefixed frame layout as `ProtoSerializer` (totalLen, nameLen, type name, payload). Type names are the lowercased `reflect.Type` string used by the package-level types registry (`internal/types.Registry`).

- **Type registry:** All `CBORSerializer` instances share a single global registry. Types must be registered before use via `remote.RegisterSerializableTypes(new(MyMessage), ...)`. When using `WithSerializers(new(MyMessage), remote.NewCBORSerializer())` or `WithClientSerializers(..., remote.NewCBORSerializer())`, the same type must be registered for the **receive** path (deserialize resolves the concrete type by name from the registry). Register receive-only types explicitly with `RegisterSerializableTypes`.
- **Performance:** Single allocation for the frame on encode; stack-allocated 8-byte header; registry lookups use `internal/types.Registry` backed by `xsync.Map` (lock-free reads). Two allocations per serialize (frame + CBOR library output), one per deserialize (target value).
- **Options:** `WithSerializers` / `WithClientSerializers` bind a serializer to a concrete type or interface; the default remains `ProtoSerializer` for `proto.Message`.
- **Serializer propagation:** User-defined serializers registered via `WithSerializers` on `remote.Config` are automatically forwarded to the outbound client. Both the server (inbound deserialization) and the client (outbound serialization) use the same set of serializers when configured via `WithRemoteConfig`.

---

### 12. `internal/commands` package

A new `internal/commands` package provides the internal command abstraction previously implemented inline in `pid.go` and `actor_system.go`. Extracted to reduce coupling and improve testability of the actor lifecycle machinery.

---

## Breaking Changes (continued)

### 14. `PID` is the sole actor reference — `ActorRef` removed

The `ActorRef` struct (defined in `actor/actor_ref.go`) has been deleted. `*PID` is now the single, unified handle for both **local** and **remote** actors.

- A local PID has a live mailbox, supervision state, and a full actor-system reference.
- A remote PID is a lightweight value that carries only the actor's `*address.Address` and a remoting handle; all messaging is dispatched through the remoting layer.
- Use `pid.IsLocal()` / `pid.IsRemote()` to distinguish the two when location matters.

**Migration:** Replace every `ActorRef` type annotation with `*PID`. Methods that returned `ActorRef` slices now return `[]*PID`.

---

### 15. `ActorSystem.ActorOf` — unified single-return signature

`ActorOf` previously returned three values `(addr *address.Address, pid *PID, err error)`. It now returns `(*PID, error)`.

| Case                   | Old return         | New return                                  |
|------------------------|--------------------|---------------------------------------------|
| Actor found locally    | `(addr, pid, nil)` | `(pid, nil)` — live local PID               |
| Actor found in cluster | `(addr, nil, nil)` | `(pid, nil)` — lightweight remote PID |
| Not found              | `(nil, nil, err)`  | `(nil, err)`                                |

**Migration:** Update all call sites. Use `pid.Path()` to obtain the actor path (host, port, name, system) and `pid.IsLocal()` / `pid.IsRemote()` to test location.

---

### 16. `ActorSystem.Actors` — merged with `ActorRefs`, returns `([]*PID, error)`

`Actors() []*PID` (local-only, no error) and `ActorRefs(ctx, timeout) ([]ActorRef, error)` (cluster-aware) have been merged into a single method:

```go
Actors(ctx context.Context, timeout time.Duration) ([]*PID, error)
```

Local actors are returned as live PIDs; cluster actors on peer nodes are returned as remote PIDs. The `timeout` parameter bounds the cluster scan and is ignored when not in cluster mode.

**Migration:** Replace calls to `Actors()` with `Actors(ctx, timeout)` and calls to `ActorRefs(...)` with `Actors(ctx, timeout)`.

---

### 17. `ActorSystem.LocalActor` removed

`LocalActor(actorName string) (*PID, error)` has been deleted. Use `ActorOf` instead — it performs a fast local-tree lookup first and only falls through to the cluster when the actor is not found locally.

**Migration:** Replace `sys.LocalActor(name)` with `sys.ActorOf(ctx, name)`.

---

### 18. `ActorSystem.RemoteActor` removed

`RemoteActor(ctx, actorName) (*address.Address, error)` has been deleted. `ActorOf` already covers the cluster lookup path and returns a remote PID.

**Migration:** Replace `sys.RemoteActor(ctx, name)` with `sys.ActorOf(ctx, name)` and use `pid.Path()` to inspect host, port, and name.

---

### 19. Remote-specific scheduler methods removed

The three `Remote*` variants of the scheduler API have been removed from `ActorSystem`:

- `RemoteScheduleOnce(ctx, message, receiver *address.Address, delay, opts…)`
- `RemoteSchedule(ctx, message, receiver *address.Address, interval, opts…)`
- `RemoteScheduleWithCron(ctx, message, receiver *address.Address, cron, opts…)`

**Migration:** Obtain a remote PID via `ActorOf` (or construct one internally) and pass it to the unified `ScheduleOnce`, `Schedule`, or `ScheduleWithCron` methods. The scheduler now routes through the remoting layer automatically when the target PID is remote.

---

### 20. `ActorSystem.GetPartition` renamed to `Partition`

The method has been renamed for consistency with Go naming conventions.

**Migration:** Replace `sys.GetPartition(name)` with `sys.Partition(name)`.

---

### 21. Remoting client no longer exported from `remote`

The remoting client is no longer part of the public API. The `remote` package now exposes only configuration and protocol types (`Config`, `Serializer`, `Compression`, `ContextPropagator`, `SpawnRequest`, etc.). The remoting client is created internally by the actor system and `client.Node` when remoting is configured.

**Migration:**
- Replace `remote.Remoting` / `remote.Client` — use the actor system and `client.Node` APIs instead; configure remoting via `remote.Config` and `WithRemoteConfig`.
- Replace `remote.NewRemoting()` / `remote.NewClient()` — the remoting client is constructed internally; use `WithRemoteConfig(config)` when creating a `client.Node`, or configure the actor system with a remote config.
- For tests: use `mockremote.NewClient(t)` if you need to inject a mock remoting implementation.

---

### 22. `client.Node.Remoting()` and `WithRemoting` removed

The `Remoting()` accessor on `client.Node` no longer exists. The `WithRemoting` option has been removed; remoting is configured exclusively via `WithRemoteConfig(config *remote.Config)`. The node constructs its remoting client from the config (compression, timeouts, and user-defined serializers are forwarded automatically).

---

### 23. `testkit.Probe.SenderAddress()` removed

`SenderAddress() *address.Address` has been removed from the `Probe` interface and its implementation. Because `PID` is now the unified actor reference and carries the address for both local and remote actors, callers can inspect the sender via `Sender()` and then call `pid.IsRemote()` / `pid.Path()` as needed.

---

### 23a. `ReceiveContext.SenderAddress()` and `ReceiveContext.ReceiverAddress()` removed

`SenderAddress() *address.Address` and `ReceiverAddress() *address.Address` have been removed from `ReceiveContext`. The unified `*PID` type carries the address for both local and remote actors.

**Migration:** Use `ctx.Sender().Path()` when the sender is non-nil and `ctx.Self().Path()` for the receiver. This aligns with the removal of `Probe.SenderAddress()` and keeps a single way to obtain actor identity via `PID`.

---

### 24. `PID.Kind()` — actor kind accessor

A new public method returns the reflected type name of the actor backing the PID:

```go
func (pid *PID) Kind() string
```

Returns an empty string for remote PIDs (which carry no actor instance).

---

### 25. Remote PID — lightweight cross-node actor handle

`newRemotePID` is an internal constructor that creates a minimal PID representing an actor on a remote node. It carries only the actor address and a remoting handle; all messaging is forwarded through the remoting layer. Remote PIDs are returned by `ActorOf` when an actor is found in the cluster but not locally.

---

### 26. `errors.ErrRemotingDisabled` and `errors.ErrNotLocal`

Two new sentinel errors have been added to the `errors` package:

- `ErrRemotingDisabled` — returned when a remote operation is attempted but remoting is not configured.
- `ErrNotLocal` — returned when an operation requires a local PID but a remote PID is provided.

---

## Bug Fixes

### 27. `cleanupCluster` singleton kind removal

**Problem:** During node shutdown, `cleanupCluster` was checking `pid.IsSingleton()` to decide whether to call `cluster.RemoveKind`. However, `pid.reset()` — which is called as part of actor shutdown — clears `singletonState` to `false`. By the time `cleanupCluster` ran, all actors had already been stopped, so `IsSingleton()` always returned `false` and `RemoveKind` was never called. The stale kind entry in the cluster store then prevented the new leader from spawning the relocated singleton (`ErrKindAlreadyExists` / `ErrSingletonAlreadyExists`).

**Fix:** `cleanupCluster` now checks `pid.singletonSpec != nil` instead of `pid.IsSingleton()`. `singletonSpec` is set at spawn time and is never cleared by `reset()`, so it correctly identifies singleton PIDs regardless of their running state.

---

## Internal Improvements

### 28. `address.Address.String()` — eager caching

`cachedStr` is now computed once inside the `New` and `NewWithParent` constructors rather than lazily on the first `String()` call. This makes `String()` a pure, safe concurrent read with zero branching and eliminates the one-time write-race window that existed under the lazy approach.

---

### 29. `internal/xsync.List` — deduplication and low-GC redesign

The generic list type gained several improvements:

- Type parameter tightened from `any` to `comparable`, enabling built-in deduplication.
- `Append` and `AppendMany` are now no-ops for items already present.
- New `Contains(item T) bool` method.
- Pre-allocated backing array (`cap=4`) to avoid the first resize on small lists.
- Cleared slots are zeroed immediately on `Reset` to prevent pointer/interface values from blocking GC.
- `Get` accesses the element while holding the read lock, preventing a concurrent reallocation from invalidating a bounds check that was performed before the lock.

---

### 30. Scheduler — unified local/remote delivery

`makeJobFn` in `actor/scheduler.go` was refactored to remove the separate remote-PID check. `PID.Tell` already handles the local/remote routing decision internally, so the scheduler passes the target PID directly to `Tell` without any `IsRemote` branching, keeping the hot path allocation-free.

The `scheduler` struct now holds an explicit `actorSystem` reference (passed at construction) so that `NoSender()` can be obtained without calling `pid.ActorSystem()` — which returns `nil` for remote PIDs and would have panicked.

---

### 31. `toReceiveContext` — else-branch elimination

`toReceiveContext` in `actor/api.go` was refactored to remove redundant `else` branches. Remote-message deserialization now mutates `from` and `message` in place before a single unconditional `receiveContext.build` call at the end of the function.

---

### 32. Remoting client as implementation detail

The remoting client is not part of the public API. The `remote` package exposes configuration (`Config`, `Option`, `WithSerializers`), protocol types (`SpawnRequest`, `GrainRequest`, `Serializer`), and built-in serializers (`ProtoSerializer`, `CBORSerializer`). The remoting client is created internally by the actor system and `client.Node` when remoting is enabled.

---

## Remote Capabilities

The remoting layer enables actors to communicate across process boundaries. It consists of a **server** (inbound, configured via `remote.Config`) and a **client** (outbound, created internally). Both share the same serializers, compression, and context propagation settings.

### Transport and security

- **Protocol:** Custom length-prefixed TCP frames. Messages are serialized (ProtoSerializer or CBOR by default), optionally compressed, and sent over pooled connections.
- **TLS:** Optional; configure when setting up the actor system or client node. When enabled, all traffic is encrypted.
- **Compression:** Configurable per `remote.Config`; the client inherits from the config. Both must agree. Options: `NoCompression`, `GzipCompression`, `ZstdCompression` (default), `BrotliCompression`.

### Server configuration (`remote.Config`)

| Option                                   | Purpose                                                                    |
|------------------------------------------|----------------------------------------------------------------------------|
| `NewConfig(bindAddr, bindPort, opts...)` | Create config with bind address and port.                                  |
| `WithWriteTimeout`                       | Timeout after which a connection is closed if no data can be written.      |
| `WithReadIdleTimeout`                    | Timeout for health checks; ping frame sent if no frame received.           |
| `WithMaxFrameSize`                       | Max frame size (16KB–16MB).                                                |
| `WithCompression`                        | Compression algorithm (must match client).                                 |
| `WithContextPropagator`                  | Inject/extract context values across remoting boundaries (e.g. trace IDs). |
| `WithSerializers`                        | Register per-type or per-interface serializers.                            |

Accessors: `BindAddr()`, `BindPort()`, `Compression()`, `IdleTimeout()`, `MaxIdleConns()`, `DialTimeout()`, `KeepAlive()`, `Serializer(msg)`, `Serializers()`.

### Outbound client configuration

The remoting client is created internally by the actor system and `client.Node`. Configuration is inherited from `remote.Config` when using `WithRemoteConfig(config)`. User-defined serializers registered via `WithSerializers` on the config are automatically forwarded to the client. Connection pooling, timeouts, and compression are set via the config options (`Compression`, `MaxIdleConns`, `DialTimeout`, `KeepAlive`, `IdleTimeout`).

### Messaging operations

| Method                                             | Description                                                        |
|----------------------------------------------------|--------------------------------------------------------------------|
| `RemoteTell(ctx, from, to, message)`               | Fire-and-forget message to a remote actor.                         |
| `RemoteAsk(ctx, from, to, message, timeout)`       | Request/response; returns first reply or error.                    |
| `RemoteBatchTell(ctx, from, to, messages)`         | Multiple fire-and-forget messages in one RPC.                      |
| `RemoteBatchAsk(ctx, from, to, messages, timeout)` | Multiple requests; returns all responses collected before timeout. |

All messages are serialized via the configured serializers. `from` and `to` are `*address.Address`; `message` is `any`.

### Actor lifecycle operations

| Method                                       | Description                                        |
|----------------------------------------------|----------------------------------------------------|
| `RemoteLookup(ctx, host, port, name)`        | Resolve address of a named actor on a remote node. |
| `RemoteSpawn(ctx, host, port, spawnRequest)` | Create a new actor on the remote node.             |
| `RemoteReSpawn(ctx, host, port, name)`       | Restart an existing actor.                         |
| `RemoteStop(ctx, host, port, name)`          | Terminate an actor.                                |
| `RemoteReinstate(ctx, host, port, name)`     | Resume a passivated actor.                         |

`SpawnRequest` carries: `Name`, `Kind`, `Singleton` (optional `SingletonSpec`), `Relocatable`, `PassivationStrategy`, `Dependencies`, `EnableStashing`, `Reentrancy`, `Supervisor`, `Role`.

### Spawning actors remotely

Use `Spawn` with `WithHostAndPort(host, port)` to create an actor on a remote node. Remoting must be enabled on the actor system (configured via a remote config). The actor type must be registered on the remote node (e.g. via `ClusterConfig.WithKinds` when configuring the remote actor system).

**Example:**

```go
// Actor system with remoting enabled (remote config set at startup)
pid, err := system.Spawn(ctx, "my-actor", NewMyActor(),
    WithHostAndPort("192.168.1.10", 9000),
    WithRelocationDisabled(),  // optional
    WithDependencies(dep1, dep2), // optional
)
if err != nil {
    return err
}
// pid is a remote PID; Tell/Ask route through the remoting layer
```

**Spawn options that apply to remote spawn:**

| Option                              | Description                                                         |
|-------------------------------------|---------------------------------------------------------------------|
| `WithHostAndPort(host, port)`       | Target host and port of the remote node. Required for remote spawn. |
| `WithRelocationDisabled()`          | Actor will not be relocated if the host node fails.                 |
| `WithDependencies(...)`             | Dependencies injected into the actor on the remote node.            |
| `WithStashing()`                    | Enable stashing on the remote actor.                                |
| `WithPassivationStrategy(strategy)` | Passivation behavior on the remote node.                            |
| `WithReentrancy(reentrancy)`        | Reentrancy policy for async requests.                               |
| `WithSupervisor(supervisor)`        | Supervisor strategy for failure handling.                           |
| `WithRole(role)`                    | Require the remote node to advertise the given role.                |

If remoting is not enabled, `Spawn` with `WithHostAndPort` returns `errors.ErrRemotingDisabled`.

### Grain operations

| Method                                                            | Description                          |
|-------------------------------------------------------------------|--------------------------------------|
| `RemoteActivateGrain(ctx, host, port, grainRequest)`              | Activate a grain on the remote node. |
| `RemoteTellGrain(ctx, host, port, grainRequest, message)`         | Fire-and-forget message to a grain.  |
| `RemoteAskGrain(ctx, host, port, grainRequest, message, timeout)` | Request/response to a grain.         |

`GrainRequest` carries: `Name`, `Kind`, `Dependencies`, `ActivationTimeout`, `ActivationRetries`, `MailboxCapacity`. The grain kind must be registered on the remote actor system using `RegisterGrainKind`.

### Context propagation

`ContextPropagator` injects context values (e.g. trace IDs, auth tokens) into outbound metadata and extracts them on the receiving side. The carrier is `net/http.Header`. Configure via `WithContextPropagator` (server) and `WithClientContextPropagator` (client). Propagated values are available in `ReceiveContext.Context()` and `GrainContext.Context()` during message handling.

### Serialization

- **Default:** `ProtoSerializer` for all `proto.Message` implementations.
- **CBOR:** `remote.NewCBORSerializer()` for arbitrary Go types. Register types with `remote.RegisterSerializableTypes(new(MyMessage), ...)`.
- **Custom:** Implement `remote.Serializer` and register via `WithSerializers` on `remote.Config`. Serializers are forwarded to the client automatically when using `WithRemoteConfig`.

---

---

## Breaking Changes (continued)

### 33. `address` package moved to `internal/address`

The top-level `address` package (`github.com/tochemey/goakt/v4/address`) has been moved to `github.com/tochemey/goakt/v4/internal/address`. It is now an internal package and can no longer be imported by external consumers.

**Migration:** Remove all direct imports of `github.com/tochemey/goakt/v4/address`. The actor path and identity information formerly obtained via `*address.Address` is now accessible through the `Path` interface returned by `pid.Path()` (see §34–35).

---

### 34. `PID.Address()` replaced by `PID.Path()`

`func (pid *PID) Address() *address.Address` has been removed. The replacement is:

```go
func (pid *PID) Path() Path
```

`Path` returns a `Path` interface (see §35) that provides location-transparent access to the actor's host, port, name, system, and parent. It returns `nil` when called on a nil PID.

| Old call                      | New call / equivalent          |
|-------------------------------|--------------------------------|
| `pid.Address().String()`      | `pid.Path().String()`          |
| `pid.Address().Name()`        | `pid.Path().Name()`            |
| `pid.Address().Host()`        | `pid.Path().Host()`            |
| `pid.Address().Port()`        | `pid.Path().Port()`            |
| `pid.Address().HostPort()`    | `pid.Path().HostPort()`        |
| `pid.Address().System()`      | `pid.Path().System()`          |
| `pid.Address().Equals(other)` | `pid.Path().Equals(otherPath)` |

**Migration:** Replace every `pid.Address()` call site with `pid.Path()` and use the `Path` interface methods. Guard against `nil` when the PID may be nil (e.g. `NoSender`).

---

## New Additions

### 35. `Path` interface — location-transparent actor identity

A new `Path` interface defined in the `actor` package provides a read-only, location-transparent view of an actor's identity:

```go
type Path interface {
    Host()     string
    HostPort() string
    Port()     int
    Name()     string
    Parent()   Path
    String()   string
    System()   string
    Equals(other Path) bool
}
```

`Path` is returned by `PID.Path()` and is the canonical way to inspect an actor's address fields without depending on the `address` package. The concrete implementation pre-computes and caches `String()` and `HostPort()` at construction time so repeated calls are zero-allocation field reads. `Equals` is a single cached-string comparison.

---

## Internal Improvements

### 36. `actor/actor_path.go` — low-GC path implementation

The `path` struct that backs the `Path` interface was redesigned for minimal GC pressure:

- **`HostPort()` is allocation-free.** The `host:port` string is pre-computed and cached in `cachedHostPort` during `newPath` using the value directly from `*address.Address`. Every subsequent call is a plain field read with no string concatenation or `strconv.Itoa`.
- **`Equals` is a single comparison.** Instead of comparing four fields (`name`, `system`, `host`, `port`), `Equals` now compares the pre-computed canonical string (`cachedStr == other.String()`), exploiting the fact that both sides already hold a cached, allocation-free string.
- **`PID.Path()` is lock-free.** The `path` field is written exactly once — inside the `newPID` / `newRemotePID` constructors — before the PID is published to any goroutine. Because it is never mutated after construction, `Path()` reads `pid.path` directly without acquiring `fieldsLocker`, eliminating an `RLock`/`RUnlock` pair on every call.

---

## V4 in brief — simplification and performance

- **Simplification:** One actor reference (`*PID`), one lookup API (`ActorOf`), one scheduler and one serializer abstraction. Messages are `any`; serialization is pluggable (ProtoSerializer by default, CBORSerializer for any Go type). The `remote` package exposes config and protocol types; the remoting client is an implementation detail, not exposed. No more `ActorRef` vs PID, no `LocalActor`/`RemoteActor`/`RemoteSchedule*` variants. Actor identity is accessed through the `Path` interface rather than a concrete `*address.Address`; the `address` package is now internal.
- **Performance:** Remoting uses a single-allocation frame and lock-free type resolution where applicable. Proto and CBOR serializers avoid extra buffers and use a shared types registry with lock-free reads. Scheduler and receive path avoid redundant branches and allocations. `PID.Path()` is lock-free; `Path.HostPort()` and `Path.Equals()` are zero-allocation after construction.
